[{"id":"cab783f99cbc9a06d74c0e9fce44b9d9","title":"javascript","content":"1,基础1,JS书写位置&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//弹出警告框\n\t\t\t// alert(\"第一个程序\");\n\t\t\t// 向控制台输出\n\t\t\t// console.log(\"你好\");\n\t\t\t// 页面输出内容\n\t\t\t// document.write(\"向页面输出内容\");\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n        &lt;!--js可以写在onclick属性中-->\n        &lt;button onclick=\"alert('别点我');\">点我一下&lt;/button>\n        &lt;!--js可以写在超链接href属性中-->\n        &lt;a href=\"javascript:alert('让你点你就得点');\">点我一下&lt;/a>\n        &lt;!--点击超链接没反应-->\n        &lt;a href=\"javascript:;\">点我一下&lt;/a>    \n     \n\t&lt;/body>\n&lt;/html>\n\n由于耦合性太高，尽量写在script标签、外部文件中\n\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\" src=\"js/script.js\">\n\t\t\t//一旦用于外部文件，此处不能编写代码浏览器会自动忽略,但可以重新创建新的script标签编写\n\t\t&lt;/script>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\talert('你好，我是第二个JS代码');\n\t\t&lt;/script>>\n\t&lt;/head>\n\t&lt;body>\n        写到外部文件中，可以同时引用，利用浏览器的缓存机制\n\t&lt;/body>\n&lt;/html>\n\n2,基本语法1,注释&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script>\n\t\t/*\n\t\t多行注释,内容不会执行，但在源码中可以查看\n\t\t*/\n\t   \n\t   //单行注释，只对后面内容起作用\n\t   \n\t   /*\n\t   *1，js严格区分大小写\n\t   *2，每条语句；结尾\n\t   */\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2,字面量，变量，标识符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t/*\n\t\t*字面量1,2,3,4,5,6,7,就是一下不可改变的值\n\t\t*变量可以保存字面量，由于变量值可以随时改变，通常是使用变量去保存一个字面量\n\t\t*/\n\t       //1，声明变量不赋值\n\t\t   var a;\n\t\t   console.log(a);//没赋值undefined\n\t\t   \n\t\t   //2,声明变量后赋值\n\t\t   var a;\n\t\t   a=1231;\n\t\t   console.log(a);\n\t\t   \n\t\t   //3,声明变量同时赋值\n\t\t   var a = 323221;\n\t\t   console.log(a);\n\t\t   \n\t\t   //4，通过变量对字面量进行描述\n\t\t   var age=12;\n\t\t   \n           \n            /*\n            *js所有自主命名都是标识符\n            *可以含有字母，数字，_,$\n            *不可以以数字开始\n            *不能是ES中关键字和保留字\n            *驼峰命名法，首字母小写其余单词开头大写\n\t\t    *UTF-8都可以作为标识符\n\t\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n\n\n3,基本数据类型(6种)\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script>\n\t\t//字符串，使用单引号/双引号，单引号包含双引号\n\t\t\t// var str1 = '我说；今天天气不错';\n\t\t\t// var str2 = '我说；\"今天天气不错\"';\n\t\t\t// console.log(str1);\n\t\t\t// console.log(str2);\n\t\t\t// //倔强写法，使用转义字符\n\t\t\t// var str3 = \"\\\\我说:\\t\\\"今天\\n天气不错\\\"\";\n\t\t\t// console.log(str3);\n\t\t\n\t\t//number,所有数值包括整数，浮点数(小数)\n\t\t//以下a，b结果都为\"123\"\n\t\t    var a= 123;\n\t\t\tvar b=\"123\";\n\t\t\tconsole.log(a);\n\t\t\tconsole.log(b);\n\t\t\t//可以使用运算符typeof检查类型\n\t\t\tconsole.log(typeof a);\n\t\t\tconsole.log(typeof b);\n\t\t\t//最大值1.7976931348623157e+308\n\t\t\tconsole.log(Number.MAX_VALUE);\n\t\t\t//正无穷大Infinity\n\t\t\tconsole.log(Number.MAX_VALUE*Number.MAX_VALUE);\n\t\t\t//负无穷大-Infinity\n\t\t\tconsole.log(-Number.MAX_VALUE*Number.MAX_VALUE);\n\t\t\t//最小值5e-324\n\t\t\tconsole.log(Number.MIN_VALUE);\n\t\t\t\n\t\t\t//NaN不是数字\n\t\t\tconsole.log(\"hh\"*\"huhu\");\n\t\t\tvar h = NaN;\n\t\t\tconsole.log(typeof h);\n\t\t\t\n\t\t\t//整数运算\n\t\t\tvar c=2121+323;\n\t\t\tconsole.log(c);\n            \n\t\t\t//js浮点型运算，得到不精确结果,不要对金钱运算\n\t\t\tvar g=0.1+0.2;\n\t\t\tconsole.log(g);\n            \n            //布尔值\n\t\t\tvar bool=false;\n\t\t\tconsole.log(typeof bool);//返回boolean\n\t\t\t\n\t\t\t//NUll \n\t\t\t//表示为空的对象，返回Object\n\t\t\tvar bool1=null;\n\t\t\tconsole.log(typeof bool1);\n\t\t\t\n\t\t\t//undefined\n\t\t\t//声明变量不赋值\n\t\t\tvar b;\n\t\t\tconsole.log(b);//undefined\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n1,类型转换1，将基本数据类型转换为String，Number，Boolean\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t//转换String\n\t\t//方式一\t数据类型.toString()\n\t\t\tvar a=1212;\t\n\t\t\ta=a.toString();//直接将原变量类型转换\n\t\t\t//调用基本数据类型的toString()方法，将转换的结果返回\n\t\t\t//该方法不会影响到原变量\n\t\t\t//null和undefined没有toString()方法；、需要走方式二\n\t\t\tvar b=a.toString();\n\t\t\tconsole.log(typeof b);\n\t\t\tconsole.log(b);\n\t\t//方式二String(变量名)\n\t\t\ta=123;\n\t\t\ta=String(a);\n\t\t\ta=null;\n\t\t\ta=String(a);//null\n\t\t\ta=undefined;\n\t\t\ta=String(a);//undefined\t\n        //方式三 \"+\"\n            var c=123;\n            c=c+\"\";\n            console.log(typeof c);//String\n\t\t\t\n\t//转换Number\n\t\t//方式一Number(变量名)\n\t\t\ta=\"123\";//纯数字字符串可以转换数字\n\t\t\ta=\"abc\";//NaN\n\t\t\ta=\"\";//空串的情况下为0\n\t\t\ta=true;//1\n\t\t\ta=false;//0\n\t\t\ta=null;//0\n\t\t\ta=undefined;//NaN\n\t\t\ta=Number(a);\n\t\t//方式二专门对付字符串，这两个函数参数为字符串\n\t\t\ta=true;//非数字字符串\n\t\t\ta=parseInt(a);NaN\n\t\t\ta=\"1234px\";\n\t\t\ta=parseInt(a);//将字符串有效整数取出转换为Number,1234\n\t\t\ta=\"1762.2788px\";\n\t\t\ta=parseFloat(a);//将字符串有效小数取出1762.2788\n\t\t//方式三使用一元运算符\n            a=\"123\";\n            a=+a;//将字符串转换为数字型\n            \n            a=1++\"2\"+3;//6\n            \n    //转换为Boolean\n        //方式一Boolean()\n            //数字转布尔，除了0，NaN都为true\n            a=123;\n            console.log(Boolean(a));//true\n            a=0;\n            console.log(Boolean(a));//false\n            a=NaN;\n            console.log(Boolean(a));//false\n            \n            //字符串转为布尔，除了空串，其余true\n            //对象也会转换为true\n            a=Null;\n            console.log(Boolean(a));//false\n            a=undefined;\n            console.log(Boolean(a));//false\n           //方式二隐式转换！！\n           //任意数据类型做两次非运算即可转换布尔值\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2，其他进制数&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t　\t\tvar a;\n\t\t\ta=0x10;\t//表示十六进制\n\t\t\tconsole.log(a);//10\n\t\t\t\n\t\t\ta=070;//表示八进制，不同浏览器可能会当十进制解析\n\t\t\ta=parseInt(a);\n\t\t\tconsole.log(a);//56\n\t\t\t\n\t\t\ta=\"070\";//对于数字型字符串，不同浏览器可能会当十・八进制解析\n\t\t\ta=parseInt(a,10);//需要指定10进制输出\n\t\t\tconsole.log(a);//56\n\t\t\ta=0b10;//表示二进制\n\t\t\tconsole.log(a);//2\n\t\t\t&lt;/script>\n        \n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n3，运算符1，可以对一个值、多个值进行运算，并获取运算结果，typeof获得值得类型并以String类型返回结果\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t//对于非Number数值类型进行运算时，会将这些值转换为Number然后运算\n\t\tvar sum;\n\t\tsum=true+false;//1\n\t\tresult=2+null;//2\n\t\t//任何数和NAN相加还是NAN\n\t\tresult=3+NaN;//NaN\n\t\tresult=\"jiji\"+\n\t\t\t\t\"ni\";//两个为字符串会拼串\n            \n\t\t//任何值和字符串相加，先转换字 符串后拼接\n\t\tresult=123+\"21\";12321\"\"\n\t\tresult=true+\"hello\";//\"truehello\"\n\t\t\n\t\t //除了+，其余运算转换为Number\n\t\tresult=2*undefined;//NaN\n\t\t//隐式转换\n\t\t//为一个值-0、*1、/1转换为Number\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n1，一元运算符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t//一元运算符，只需要一个操作数，typeof\n\t\t//+ 正号 (不会对数字有影响)\n\t\t//- 负号 (取反操作)\n\t\tvar a = 123;\n\t\ta=-a;//-123\n\t\t//对于非Number类型转换Number\n\t\ta=true;//true//boolean\n\t\ta=-a;//-1//Number\n\t\tconsole.log(a);\n\t\tconsole.log(typeof a);\n\t\t\n\t\tvar b=1;\n\t\tconsole.log(b++);//结果是1，b是2\n\t\t\n\t\t//单独的b++/++b结果都是相同的\n\t\t++b;//++前自增\n\t\tb++;//后自增++\n\t\tconsole.log(b++);//结果是4，b是5\n\t\tvar d=20;\n\t\tvar sum=d++ + ++d +d;//20+22+22\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n\n练习题&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t　　var ni=10,n2=20;\n\t\tvar n=ni++;\n\t\tconsole.log(n);//10;\n\t\tconsole.log(n1);//11\n\t\tn=++n1;\n\t\tconsole.log(n);//12\n\t\tconsole.log(n1);//12\n\t\tn=n2--;\n\t\tconsole.log(n);//20\n\t\tconsole.log(n2);//19\n\t\tn=--n2;\n\t\tconsole.log(n);//18\n\t\tconsole.log(n2);//18\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2，逻辑符1，逻辑运算符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t//!非运算(对布尔值取反操作)\n\t\t//!!二次取反变原值\n\t\tvar a = 123;\n\t\ta=!!a;//将数字类型转换为布尔\n\t\tconsole.log(a);\n\t\t\n\t\t//&amp;&amp;,两边为true则返回true。JS中为短路与左false直接返回\n\t\t//||,两边为false则返回false。JS中为短路或有true直接返回\n\t\t\n\t\t// 1，非布尔值(&amp;&amp;找false)\n\t\t//总结，如果第一个值是true必然返回右边的值，第一个值为false则返回第一个值\n\t\tvar sum=2 &amp;&amp; 1;\n\t\tconsole.log(sum);//1\n\t\tsum= 0 &amp;&amp; 2;\n\t\tconsole.log(sum);//0\n\t\tsum= NaN &amp;&amp; 0;\n\t\t// 2，非布尔值(||找true)\n\t\t//总结，第一个值是true返回第一个值，第一个值是false返回第二个值\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2，赋值运算符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//=可以将负号右侧值赋值给符号左侧变量\n\t\t\t//+=\n\t\t\tvar a=10;\n\t\t\t//a=a+5;\n\t\t\ta+=5;\n\t\t\tconsole.log(a);\n\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n3，关系运算符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//=可以将负号右侧值赋值给符号左侧变量\n\t\t\t//+=\n\t\t\tvar a=10;\n\t\t\t//a=a+5;\n\t\t\ta+=5;\n\t\t\tconsole.log(a);\n\t\t\t//数值>,>=,&lt;,&lt;=结果波尔类型\n\t\t\t\n\t\t\t\n\t\t//非数值比较\n\t\t\tconsole.log(1>\"0\");//true\n\t\t\tconsole.log(1>true);//false\n\t\t\tconsole.log(10>null);//true\n\t\t\t//任何值和Null作比较都是false\n\t\t\t//两边为字符串比较时，会转换为字符中的Unicode编码比较\n\t\t\tconsole.log(\"a\">\"b\");//false\n            //比较两个字符串型的数字，最好有一边转型为整数\n            console.log(\"2312311\"&lt;+\"4\");\n\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n\nunicode&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t//这里输入的是十六进制的代码\n\t\tconsole.log(\"\\u2620\");\n\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t\t//这里输入的是10进制位\n\t\t&lt;h1>&amp;#9760&lt;/h1>\n\t&lt;/body>\n&lt;/html>\n\n4，相等运算符&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t\t//==比较值是否相等，值类型不同，会自动类型转换相同类型比较\n\t\t\t\tconsole.log(\"1\" == 1);//true\n\t\t\t\tconsole.log(null == 0);//false\n\t\t\t\tconsole.log(null == undefined);//true\n\t\t\t\t//NaN不和任何值相等，包括本身\n\t\t\t\t\n\t\t\t\t//isNaN()函数判断值是否是NaN，是返回true\n\t\t\t\t\n\t\t\t\t//!=不相等运算，会自动类型转换相同类型比较\n\t\t\t\t//===全等，类型，值相同\n\t\t\t\t//!==不全等，值类型不同，返回true\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n5，三元运算符基本语法：条件表达式 ？a ：b\n判断两数最大值 var max&#x3D;a&gt;b ? a ：b；\n判断三数最大值var max1&#x3D;max &gt; c ? max ：c；\n​\t\t\t\t\t\t   var max2&#x3D;a &gt; b ?（ a&gt;c?  a ：c ）：（b &gt; c ? b ：c）；\n6，运算符优先级\n3，代码块所谓的代码块就是将代码分组，全局变量\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t&#123;\n\t\t\t\tvar a=12;\n\t\t\t&#125;\n\t\t\tconsole.log(a);\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body＞\n\n4，条件控制语句1，if else&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\tvar a= 10;\n\t\t\tif(a>11)\n\t\t\t\talert(\"你好\");//这种写法只有一行有效\n\t\t\t\talert(\"我必须执行\");\n\t\t\t\n\t\t\t//可以放入代码块中\n\t\t//语法1\n\t\t\tif(a>1)\n\t\t\t\t&#123;\n\t\t\t\talert(\"你好\");\n\t\t\t\talert(\"我必须执行\");\n\t\t\t\t&#125;\n\t\t\n\t\t\tif(a>1)&#123;\n\t\t\t\t\talert(\"你好\");\n\t\t\t\t\t&#125;\n\t\t//语法2\n\t\t\tif(条件表达式)&#123;\n\t\t\t\t\n\t\t\t&#125;else&#123;\n\t\t\t\t\n\t\t\t&#125;\n\t\t//语法3\n\t\t\tif(条件表达式)&#123;\n\t\t\t\t\n\t\t\t&#125;else if(条件表达式)&#123;\n\t\t\t\t\n\t\t\t&#125;else if(条件表达式)&#123;\n\t\t\t\t\n\t\t\t&#125;else&#123;\n\t\t\t\t\n\t\t\t&#125;\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n练习&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t\n\t\t\t// var num =prompt(\"请您输入成绩\");\n\t\t\t// 以下程序不安全\n\t\t\t// if(num == 100)&#123;\n\t\t\t// \talert(\"奖励你一台宝马汽车\");\n\t\t\t// &#125;else if(num >= 80)&#123;\n\t\t\t// \talert(\"奖励你iphone 14 pro max\");\n\t\t\t// &#125;else if(num >= 60)&#123;\n\t\t\t// \talert(\"奖励你一本参考书\");\n\t\t\t// &#125;else&#123;\n\t\t\t// \talert(\"奖励你nothing\");\n\t\t\t// &#125;\t\t\n\t\t\t//最好需要将条件进行过滤\n\t\t\t// if(num > 100 || num &lt; 0 || isNaN(num))&#123;\n\t\t\t// \talert(\"您输入值不在范围内\");\n\t\t\t// &#125;else&#123;\n\t\t\t// \tif(num == 100)&#123;\n\t\t\t// \t\talert(\"奖励你一台宝马汽车\");\n\t\t\t// \t&#125;else if(num >= 80)&#123;\n\t\t\t// \t\talert(\"奖励你iphone 14 pro max\");\n\t\t\t// \t&#125;else if(num >= 60)&#123;\n\t\t\t// \t\talert(\"奖励你一本参考书\");\n\t\t\t// \t&#125;else&#123;\n\t\t\t// \t\talert(\"奖励你nothing\");\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t// var height = prompt(\"请输入您的身高\");\n\t\t\t// var money = prompt(\"请输入您的财产\");\n\t\t\t// var face = prompt(\"请输入您的颜值\");\n\t\t\t// if(height > 180 &amp;&amp; money > 1000 &amp;&amp; face >500)&#123;\n\t\t\t// \talert(\"我一定嫁给你\");\n\t\t\t// &#125;else if(height > 100 || money > 1000 || face > 500)&#123;\n\t\t\t// \talert(\"勉强能嫁\");\n\t\t\t// &#125;else&#123;\n\t\t\t// \talert(\"一边去\");\n\t\t\t// &#125;\n\t\t\t\n\t\t\t// 比较三个数大小\n\t\t\tvar num1=+prompt(\"请输入第一个数字\");\n\t\t\tvar num2=+prompt(\"请输入第二个数字\");\n\t\t\tvar num3=+prompt(\"请输入第三个数字\");\n\t\t\tif(num1 &lt; num2 &amp;&amp; num1 &lt;num3)&#123;\n\t\t\t\talert(\"第一个数字最小\");\n\t\t\t\tif(num2 &lt; num3)&#123;\n\t\t\t\t\talert(num1+\",\"+num2+\",\"+num3);\n\t\t\t\t&#125;else&#123;\n\t\t\t\talert(num1+\",\"+num3+\",\"+num2);\n\t\t\t\t&#125;\n\t\t\t&#125;else if(num2 &lt; num1 &amp;&amp; num2 &lt; num3)&#123;\n\t\t\t\talert(\"第二个数字最小\");\n\t\t\t\tif(num1 &lt; num3)&#123;\n\t\t\t\t\talert(num2+\",\"+num1+\",\"+num3);\n\t\t\t\t&#125;else&#123;\n\t\t\t\talert(num2+\",\"+num3+\",\"+num1);\n\t\t\t\t&#125;\n\t\t\t&#125;else&#123;\n\t\t\t\talert(\"第三个数字最小\");\n\t\t\t\tif(num1 &lt; num2)&#123;\n\t\t\t\t\talert(num3+\",\"+num1+\",\"+num2);\n\t\t\t\t&#125;else&#123;\n\t\t\t\talert(num3+\",\"+num2+\",\"+num1);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&lt;/script>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2，switch&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//条件表达式和表达式进行全等比较\n\t  //     swich(条件表达式)&#123;\n\t\t\t// case 表达式:\n\t\t\t//    语句;\n\t\t\t//    break;\n\t\t\t// case 表达式:\n\t\t\t//    语句;\n\t\t\t//    break;\n\t\t\t// case 表达式:\n\t\t\t//    语句;\n\t\t\t//    break;\n\t\t\t// default:\n\t\t\t//   语句;\n\t\t\t//   break;\n\t\t //  &#125;\n\t\t \n\t\t //case具有穿透现象\n\t\t // var score=69;\n\t\t // switch(score)&#123;\n\t\t // case 50:\n\t\t // case 60:\n\t\t // case 44:\n\t\t // case 40:\n\t\t // console.log(\"合格\");\n\t\t // break;\n\t\t // &#125;\n\t\t \n\t\t // var score=99;\n\t\t // switch(parseInt(score%10))&#123;\n\t\t\t//  case 10:\n\t\t\t//  case 9:\n\t\t\t//  case 6:\n\t\t\t//  \tconsole.log(\"合格\");\n\t\t\t//  \tbreak;\n\t\t\t//  default:\n\t\t\t//  \tconsole.log(\"不合格\");\n\t\t\t// \t    break;\n\t\t // &#125;\n\t\t \n\t\t // switch(true)&#123;\n\t\t\t// case score>=60:\n\t\t\t// \t\tconsole.log(\"合格\");\n\t\t\t// \t\tbreak;\n\t\t\t// default:\n\t\t\t// \t\tconsole.log(\"不合格\");\n\t\t\t// \t\tbreak;\n\t\t // &#125;\n\t\t&lt;/script>\n\t\t\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n5,循环语句1,while1，初始化变量2，循环中设置条件表达式3，定义更新表达式&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t//while循环\n\t\t//先判断在执行\n\t\tvar i=0;\n\t\twhile(i&lt;10)&#123;\n\t\t\ti++;\n\t\t&#125;\n\t\t\n\t\t//练习1\n\t\tvar year=0;\n\t\tvar money=1000;\n\t\twhile(money&lt;=5000)&#123;\n\t\t\tmoney *=1.05;\n\t\t\tyear++;\n\t\t&#125;\n\t\t//练习2\n\t\twhile(true)&#123;\n\t\t\tvar num =prompt(\"请您输入成绩\");\n\t\t\tif(num >= 0 &amp;&amp; score &lt;= 100)&#123;\n\t\t\t\tbreak;//如果输入正确退出循环\n\t\t\t&#125;\n\t\t\talert(\"请输入有效的值\");\n\t\t&#125;\n\t\tif(num == 100)&#123;\n\t\t\talert(\"奖励你一台宝马汽车\");\n\t\t&#125;else if(num >= 80)&#123;\n\t\t\talert(\"奖励你iphone 14 pro max\");\n\t\t&#125;else if(num >= 60)&#123;\n\t\t\talert(\"奖励你一本参考书\");\n\t\t&#125;else&#123;\n\t\t\talert(\"奖励你nothing\");\n\t\t&#125;\n\t\t\t\n\t\t\t\t\t\t\t\n\t\t//do while\n\t\t//先执行后判断\n\t\tdo&#123;\n\t\t\t语句;\n\t\t&#125;while(条件表达式)\n\t\t&lt;/script>\n\t\t\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n2,for&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//初始化表达式执行一次\n\t\t\t// for(初始化表达式;条件表达式;更新表达式)&#123;\n\t\t\t// \t语句;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//无限循环\n\t\t\t// for(;;)&#123;\n\t\t\t// \talert(\"hello\");\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//打印1-100之间奇数和\n\t\t\t// var sum=0;\n\t\t\t// for(var=1;i&lt;=100;i++)&#123;\n\t\t\t// \tif(i%2 !=0)&#123;\n\t\t\t// \t\tsum+=i;\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//打印7倍数\n\t\t\t// var sum=0;\n\t\t\t// var count=0;\n\t\t\t// for(var i=1;i&lt;=100;i++)&#123;\n\t\t\t// \tif(i % 7==0)&#123;\n\t\t\t// \t\tsum+=i;\n\t\t\t// \t\tcount++;\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//打印水仙花\n\t\t\t// for(var i=100;i&lt;=1000;i++)&#123;\n\t\t\t// \tvar bai=parseInt(i/100);\n\t\t\t// \tvar shi=parseInt((i%100)/10);\n\t\t\t// \tvar ge=i%10;\n\t\t\t// \tif(bai*bai*bai +shi*shi*shi +ge*ge*ge==i)&#123;\n\t\t\t// \t\tconsole.log(\"我是水仙花\"+i);\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//打印质数\n\t\t\t// var num =prompt(\"请输入大于1的整数\");\n\t\t\t// if(num&lt;=1)&#123;\n\t\t\t// \talert(\"输入的值不合法\");\n\t\t\t// &#125;else&#123;\n\t\t\t// \tvar flag=true;\n\t\t\t// \tfor(var i=2;i&lt;num;i++)&#123;\n\t\t\t// \t\tif(num % i==0)&#123;\n\t\t\t// \t\t\t//表示一定不是质数\n\t\t\t// \t\t\tflag=false;\n\t\t\t// \t\t&#125;\n\t\t\t// \t&#125;\n\t\t\t// \tif(flag)&#123;\n\t\t\t// \t\tconsole.log(num);\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t&lt;/script>\n\t\t\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n嵌套for循环\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\tfor(var i=0;i&lt;6;i++)&#123;\n\t\t\t\tfor(var j=0;j&lt;i+1;j++)&#123;\n\t\t\t\t\tdocument.write(\"*&amp;nbsp;&amp;nbsp;\");\n\t\t\t\t&#125;\n\t\t\t\tdocument.write(\"&lt;br />\");\n\t\t\t&#125;\n\t\t&lt;/script>\n\t\t\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\tfor(var i=0;i&lt;6;i++)&#123;\n\t\t\t\tfor(var j=0;j&lt;5-i;j++)&#123;\n\t\t\t\t\tdocument.write(\"*&amp;nbsp;&amp;nbsp;\");\n\t\t\t\t&#125;\n\t\t\t\tdocument.write(\"&lt;br />\");\n\t\t\t&#125;\n\t\t&lt;/script>\n\t\t\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n99乘法表\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\tfor(var i=1;i&lt;=9;i++)&#123;\n\t\t\t\tfor(var j=1;j&lt;=i;j++)&#123;\n\t\t\t\t\tdocument.write(\"&lt;span>\"+i+\"*\"+j+\"=\"+i*j+\"&lt;/span>\");\n\t\t\t\t&#125;\n\t\t\t\tdocument.write(\"&lt;br />\");\n\t\t\t&#125;\n\t\t\t\n\t\t&lt;/script>\n\t\t&lt;style type=\"text/css\">\n\t\t\tspan&#123;\n\t\t\t\twidth:80px;\n\t\t\t\tdisplay:inline-block;\n\t\t\t&#125;\n\t\t\t\n\t\t&lt;/style>\n\t&lt;/head>\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n打印质数\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\tfor(var i=2;i&lt;=100;i++)&#123;\n\t\t\t\tvar flag=true;\n\t\t\t\tfor(var j=2;j&lt;i;j++)&#123;\n\t\t\t\t\tif(i%j==0)&#123;\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t\tif(flag)&#123;\n\t\t\t\t\tconsole.log(i);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&lt;/script>\n\t&lt;/head>\t\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n3，break，continuebreak可以用来退出switch&#x2F;循环语句，不能在if语句中使用\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t// for(var i=0;i&lt;=100;i++)&#123;\n\t\t\t// \tconsole.log(i);//0\n\t\t\t// \tbreak;//只执行一次退出循环\n\t\t\t// &#125;\n\t\t\t\n\t\t\t// for(var i=0;i&lt;5;i++)&#123;\n\t\t\t// \tconsole.log(i);//0,1,2\n\t\t\t// \tif(i==2)&#123;\n\t\t\t// \t\tbreak;//直接退出循环\n\t\t\t// \t&#125;\n\t\t\t// &#125;\n\t\t\t\n\t\t\t//for(var i=0;i&lt;5;i++)&#123;\n\t\t\t//\tconsole.log(\"外层循环\"+i);//0,1,2,3,4\n\t\t\t//\tfor(var j=0;j&lt;i;j++)&#123;\n\t\t\t//\t\tbreak;//终止就近循环\n\t\t\t//\t&#125;\n\t\t\t//&#125;\n            \n            //outer:\n            //for(var i=0;i&lt;5;i++)&#123;\n\t\t\t\t//console.log(\"外层循环\"+i);//0,1,2,3,4\n\t\t\t\t//for(var j=0;j&lt;i;j++)&#123;\n\t\t\t\t\t//break outer;//终止外部标签循环\n\t\t\t\t//&#125;\n\t\t\t//&#125;\n            \n            \n            \n            \n            // for(var i=0;i&lt;5;i++)&#123;\n\t\t\t// \t\t跳出就近循环\n\t\t\t// \t\tif(i==2)&#123;\n\t\t\t// \t\t\tcontinue;//跳过当次循环\n\t\t\t// \t\t&#125;console.log(i);//0,1,3,4\n\t\t\t// &#125;\n\t\t&lt;/script>\n\t&lt;/head>\t\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n6，对象1，简介1，内置对象ES标准定义的对象比如Math、Number，function等\n2，宿主对象JS运行环境、浏览器提供的对象比如BOM，DOM\n3，自定义对象开发人员自己创建的对象\n2，对象的基本操作&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//创建空的对象\n\t\t\tvar obj=new object();\n\t\t\t//增加属性\n\t\t\tobj.name=\"范冰冰\";\n\t\t\tobj.gender=\"男\";\n\t\t\tobj.age=23;\n\t\t\t//读取属性，对象.属性名\n\t\t\tconsole.log(obj.name);\n\t\t\t//更改属性\n\t\t\tobj.age=32;\n\t\t\t//删除属性\n\t\t\tdelete obj.name;\n\t\t\tconsole.log(obj.name);\n            \n            \n            //属性名，什么乱七八糟的都可。特殊的属性名需要用：对象[\"属性名\"]=属性值\n            obj[\"212\"]=21;\n  \t        console.log(obj[\"212\"]);\n            //为了使用灵活可以传变量\n            obj[\"212\"]=21;\n            var n=\"212\";\n  \t        console.log(obj[n]);\n            //属性值，可以任意数据类型、对象\n            var obj1=new object();\n            obj1.name=\"猪八戒\"\n            obj.test=obj1;\n            console.log(obj.test.name);\n            \n            //检查对象中是否含有属性返回布尔值\n            console.log(\"name\" in obj1);\n\t\t&lt;/script>\n\t&lt;/head>\t\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n3，基本&#x2F;引用数据类型（&#x3D;&#x3D;引用比较地址）\n\n4，使用属性字面量&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//基本数据类型值在栈内存存储，值之间相互独立\n\t\t\t//对象保存到堆内存，每创建一个新对象就在堆里开辟一个新空间\n\t\t\tvar obj=&#123;name:\"你好\",\n\t\t\t\t\tage:32,\n\t\t\t\t\tsex:\"男\",\n\t\t\t\t\ttest:&#123;name:\"沙和尚\"&#125;\n\t\t\t\t\t&#125;;\n            console.log(obj.test);\n\t\t\t\n\t\t\t\n\t\t&lt;/script>\n\t&lt;/head>\t\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n7,函数1，概念函数也是一个对象，内部封装了一些功能代码，需要时直接调用并执行\n&lt;!DOCTYPE html>\n&lt;html>\n\t&lt;head>\n\t\t&lt;meta charset=\"utf-8\">\n\t\t&lt;title>&lt;/title>\n\t\t&lt;script type=\"text/javascript\">\n\t\t\t//直接创建一个对象函数（构造函数）\n\t\t\tvar fun = new Function(\"console.log('helloworld');\");\n\t\t\tfun();\n\t\t\t\n\t\t\t//第二种方式\n\t\t\tfunction fun()&#123;\n\t\t\t\t//多行代码\n\t\t\t&#125;\n\t\t\t\n\t\t\t//第三种方式（赋值一个匿名函数）\n\t\t\tvar fun= function()&#123;\n\t\t\t\tconsole.log(\"哈哈如何如何\");\n\t\t\t&#125;\n\t\t\tfun();\n\t\t&lt;/script>\n\t&lt;/head>\t\n\t&lt;body>\n\t&lt;/body>\n&lt;/html>\n\n","slug":"Javascript","date":"2022-11-07T15:11:36.513Z","categories_index":"前端","tags_index":"","author_index":"Aurora"},{"id":"f408f8319d61dac78e2140b3ee927dba","title":"JAVA基础","content":"1，java概述1，cmd，DOS命令win R调取cmd\n切磁盘:  C:\n\n2，计算机语言\n\n\n\nJDK，java开发环境\n\n将javase面向桌面级API除去变为JAVAEE\n3，java三大领域\n4，java语言诞生\n5，主要特性\n6，主要特点\n\n不同操作系统，JVM是不一样的\n\n从上而下依次执行\n\n7，环境搭建（JDK、JRE）\n\n\n1，\n\n不同的操作系统会有不同虚拟机，产生不同JDK、\n1，安装JDK\n2，环境变量配置path（windows系统执行命令时搜索的路径）1，配置Javahome\n2，配置path，bin目录\n\n8，HelloWorld\npublic class HelloWorld &#123;\n\n    public static void main(String[] args) &#123;\n    \n        System.out.println(\"hello world\");\n    \n    &#125;\n\n&#125;    \n\n\n\n\n源文件名不存在或者写错\n当前路径错误\n后缀名隐藏问题\n\n\n\n类文件名写错，尤其文件名与类名不一致时，要小心\n类文件不在当前路径下，或者不在classpath指定路径下\n\n\n\n声明为public的类应与文件名一致，否知编译失败\n\n\n\n编译失败，注意错误出现的行数，再到源代码中指定位置改错\n\n总结：学习编程最容易犯的错是语法错误。Java要求你必须按照语法规则编写代码。如果你的程序违反了语法规则，例如：忘记了分号、大括号、引号，或者拼错了单词，java编译器都会报语法错误。尝试着去看懂编译器会报告的错误信息。\njavac编译生成class文件，java执行此文件（默认情况当前路径下找或者配置classpath）\n9，注释（用于注解说明解释程序的文字）1，注释类型：\n单行注释\n\n格式：&#x2F;&#x2F;注释文字\n\n\n多行注释\n\n格式：&#x2F;* 注释文字*&#x2F;\n注：对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。多行注释里面不允许有多行注释嵌\n\n\n文档注释(java特有)\n/**\n * @author  指定java程序的作者**\n * @version  指定源文件的版本**\n */\n注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档。\n\n\n\n提高了代码的阅读性；调试程序的重要方法。\n\n注释是一个程序员必须要具有的良好编程习惯。\n\n将自己的思想通过注释先整理出来，再用代码去体现。\n\n\n2，API\n\n10，总结Java源文件以“java”为扩展名。源文件的基本组成部分是类（class），如本例中的HelloWorld类。Java应用程序的执行入口是main()方法。它有固定的书写格式：public static void main(String[] args) {…}Java语言严格区分大小写。Java方法由一条条语句构成，每个语句以“;”结束。大括号都是成对出现的，缺一不可。一个源文件中最多只能有一个public类。其它类的个数不限，如果源文件包含一个public类，则文件名必须按该类名命名。\n2，基本语法1，变量标识符保留字1、关键字(keyword)的定义和特点\n定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）\n特点：关键字中所有字母都为小写\n官方地址： https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html\n\n\n\n2、保留字(reserved word)Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字goto、const。\n3，标识符1，什么是标识符（Identifier）\nJava 对各种变量、方法和类等要素命名时使用的字符序列称为标识符\n技巧：凡是自己可以起名字的地方都叫标识符。\n\n2、定义合法标识符规则【重要】\n由 26 个英文字母大小写，0-9，_或$ 组成\n数字不可以开头。\n标识符不能包含空格。\n不可以使用关键字和保留字，但能包含关键字和保留字。\nJava 中严格区分大小写，长度无限制。\n\n3、Java 中的名称命名规范\n\n\n\n\n\n\n\n\n1、Java 中的名称命名规范：\n\n包名：多单词组成时所有字母都小写：xxxyyyzzz\n类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz\n变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz\n常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n\n\n\n\n\n\n\n\n\n\n2、注意点\n\n注意 1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。\n注意 2：java 采用 unicode 字符集，因此标识符也可以使用汉字声明，但是不建议使用。\n更多细节详见《代码整洁之道》\n\n4，变量（按照数据类型划分）1、变量的概念：\n内存中的一个存储区域；\n该区域的数据可以在同一类型范围内不断变化；\n变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值。\n\n\n2、变量的作用：\n用于在内存中保存数据。\n\n3、使用变量注意：\nJava 中每个变量必须先声明，后使用；\n使用变量名来访问这块区域的数据；\n变量的作用域：其定义所在的一对{ }内；\n变量只有在其作用域内才有效；\n同一个作用域内，不能定义重名的变量；\n\n4、声明变量\n语法：&lt;数据类型&gt; &lt;变量名称&gt;\n例如：int var;\n\n5、变量的赋值\n语法：&lt;变量名称&gt; &#x3D; &lt;值&gt;\n例如：var &#x3D; 10;\n\n6、声明和赋值变量\n语法：&lt;数据类型&gt;&lt;变量名&gt;&#x3D; &lt;初始化值&gt;\n例如：int var &#x3D; 10\n\n7、补充：变量的分类-按声明的位置的不同\n在方法体外，类体内声明的变量称为成员变量。\n在方法体内部声明的变量称为局部变量。\n\n\n\n\n\n\n\n\n\n\n\n二者在初始化值方面的异同:\n\n同：都有生命周期\n异：局部变量除形参外，需显式初始化。\n\n5，数据类型及转换每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。\n\n1，基本数据类型1,整数类型：byte、short、int、long\nJava 各整数类型有固定的表数范围和字段长度，不受具体 OS 的影响，以保证 java 程序的可移植性。\njava 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’\n\njava 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long\n\n\n\n\n\n类型\n占用存储空间\n表数范围\n\n\n\nbyte\n1字节&#x3D;8bit位\n-128 ~ 127\n\n\nshort\n2字节\n-2^15~ 2^15-1\n\n\nint\n4字节\n-2^31~ 2^31-1 (约21亿)\n\n\nlong\n8字节\n-2^63~ 2^63-1\n\n\n/*\nJava定义的数据类型\n\n一、变量按照数据类型来分：\n\t基本数据类型：\n\t\t整型：byte \\ short \\ int \\ long\n\t\t浮点型：float \\ double\n\t\t字符型：char\n\t\t布尔型：boolean\n\n\t引用数据类型：\n\t\t类：class\n\t\t接口：interface\n\t\t数组：array\n\n二、变量在类中声明的位置：\n\t\t成员变量 vs 局部变量\n*/\nclass VariableTest1&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//1. 整型：byte(1字节=8bit) short(2字节） \\ int (4字节）\\ long(8字节)\n\t\t//① byte范围：-128 ~ 127\n\n\t\tbyte b1 = 12;\n\t\tbyte b2 = -128;\n\t//\tb2 = 128; //编译不通过\n\t\tSystem.out.println(b1);\n\t\tSystem.out.println(b2);\n\n\t\t// ② 声明long型变量，必须以“1”或“L”结尾\n\t\tshort s1 = 128;\n\t\tint i1 = 12345;\n\t\tlong a = 345678586L;\n\t\tSystem.out.println(a);\n\t&#125;\n&#125;\n\n\n2，浮点类型float、double\n与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。\n浮点型常量有两种表示形式：\n十进制数形式：如：5.12 512.0f .512 (必须有小数点）\n科学计数法形式:如：5.12e2 512E2 100E-2\n\n\nfloat:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。\ndouble:双精度，精度是float的两倍。通常采用此类型。\nJava 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。\n\n\n\n\n类型\n占用存储空间\n表数范围\n\n\n\n单精度float\n4字节\n-3.403E38 ~ 3.403E38\n\n\n双精度double\n8字节\n-1.798E308 ~ 1.798E308\n\n\n3，字符类型：char\nchar 型数据用来表示通常意义上“字符”(2字节)\nJava中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。\n字符型变量的三种表现形式：\n字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 &#x3D; ‘a’; char c2 &#x3D; ‘中’; char c3 &#x3D; ‘9’;\nJava中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 &#x3D; ‘\\n’; &#x2F;&#x2F;’\\n’表示换行符\n直接使用Unicode值来表示字符型常量：‘\\uXXXX’。其中，XXXX代表一个十六进制整数。如：\\u000a 表示\\n。\n\n\nchar类型是可以进行运算的。因为它都对应有Unicode码。\n\n/*\nJava定义的数据类型\n\n一、变量按照数据类型来分：\n\n\t基本数据类型：\n\t\t整型：byte \\ short \\ int \\ long\n\t\t浮点型：float \\ double\n\t\t字符型：char\n\t\t布尔型：boolean\n\n\t引用数据类型：\n\t\t类：class\n\t\t接口：interface\n\t\t数组：array\n\n二、变量在类中声明的位置：\n\t\t成员变量 vs 局部变量\n*/\nclass VariableTest1&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//2. 浮点型：float(4字节) \\ double(8字节)\n\t\t//① 浮点型，表示带小数点的数值\n\t\t//② float表示数值的范围比long还大\n\n\t\tdouble d1 = 12.3;\n\t\tSystem.out.println(d1 +1);\n\t\t\n\t\t//定义float类型变量时，变量要以\"f\" 或\"F\"结尾\n\t\tfloat f1 = 12.3F;\n\t\tSystem.out.println(f1);\n\n\t\t//② 通常，定义浮点型变量时，使用double变量\n\n\t\t//3. 字符型：char(1字符=2字节（byte）=16bit)\n\t\t//① 定义char型变量，通常使用一对'' \n\t\tchar c1 = 'a';\n\t\t//编译不通过\n\t\t//c1 = 'AB';\n\t\tSystem.out.println(c1);\n\n\t\tchar c2 = '1';\n\t\tchar c3 = '中';\n\t\tchar c4 = '&amp;';\n\t\tSystem.out.println(c2);\n\t\tSystem.out.println(c3);\n\t\tSystem.out.println(c4);\n\n\t\t//② 表示方式：1.声明一个字符；2.转义字符；3.直接使用Unicode值来表示字符型常量\n\t\tchar c5 = '\\n';\t//换行符\n\t\tc5 = '\\t';\t//制表符\n\t\tSystem.out.print(\"hello\" + c5);\n\t\tSystem.out.println(\"world\");\n\n\t\tchar c6 = '\\u0123';\n\t\tSystem.out.println(c6);\n\t\t\n\t\tchar c7 = '\\u0043';\n\t\tSystem.out.println(c7);\n\t&#125;\n&#125;\n\n\n4，boolean\nboolean 类型用来判断逻辑条件，一般用于程序流程控制：\nif条件控制语句；\nwhile循环控制语句；\ndo-while循环控制语句；\nfor循环控制语句；\n\n\nboolean类型数据只允许取值true和false，无null。\n不可以使用0或非0 的整数替代false和true，这点和C语言不同。\nJava虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范8版》\n\n\n\nclass VariableTest1&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//4. 布尔型：boolean\n\t\t//① 只能取两个值之一：true 、false\n\t\t//② 常常在条件判断、循环结构中使用\n\t\tboolean bb1 = true;\n\t\tSystem.out.println(bb1);\n\n\t\tboolean isMarried = true;\n\t\tif(isMarried)&#123;\n\t\t\tSystem.out.println(\"禁止入内！\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"可以参观！\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n为了防止在Cmd乱吗，需要文件编码格式相同\nASCII 码\n在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit）有0 和1 两种状态，因此8个二进制位就可以组合出256 种状态，这被称为一个字节（byte）。一个字节一共可以用来表示256 种不同的状态，每一个状态对应一个符号，就是256 个符号，从0000000 到11111111。\nASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。\n缺点：\n不能表示所有字符。\n相同的编码表示的字符不一样：比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel(ג)。\n\n\n\nUnicode 编码\n乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。\nUnicode：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode 没有乱码的问题。\nUnicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。\n\nUTF-8\nUTF-8 是在互联网上使用最广的一种Unicode 的实现方式。\nUTF-8 是一种变长的编码方式。它可以使用1-6 个字节表示一个符号，根据不同的符号而变化字节长度。\nUTF-8的编码规则：\n对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。\n对于多字节的UTF-8编码，如果编码包含n 个字节，那么第一个字节的前n位为1，第一个字节的第n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。\n\n\n\n2，自动类型转换\n自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：\n有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。\nbyte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。\nboolean类型不能与其它数据类型运算。\n当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。\n\n/*\n基本数据类型之间的运算规则：\n\n前提：这里讨论只是7中基本数据类型变量的运算。不包含boolean类型的。\n1. 自动类型提升：\n\t当容量小的数据类型的变量和容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。\n\tchar、byte、short-->int-->long-->float-->double\n\n\t特别的：当byte、char、short三种类型的变量做运算时，结果为int类型\n\n2. 强制类型转换：\n\t\n说明：此时容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量\n*/\nclass VariableTest2&#123;\n\tpublic static void main(String[] args) &#123;\n\t\tbyte b1 = 2;\n\t\tint i1 = 129;\n\t\t//编译不通过\n//\t\tbyte b2 = b1 + i1;\n\t\tint i2 = b1 + i1;\n\t\tlong l1 = b1 + i1;\n\t\tSystem.out.println(i2);\n\t\tSystem.out.println(l1);\n\n\t\tfloat f = b1 + i1;\n\t\tSystem.out.println(f);\n\t\t//***************特别的**************************\n\t\tchar c1 = 'a';\t//97\n\t\tint i3 = 10;\n \n\t\tSystem.out.println(i4);\n\n\t\tshort s2 = 10;\n\t\t//编译错误\n//\t\tchar c3 = c1 + s2;\n\t\t\n\t\tbyte b2 = 10;\n//\t\tchar c3 = c1 + b2;\t//编译不通过\n\n//\t\tshort s3 = b2 + s2;\t//编译不通过\n\t\t\n//\t\tshort s4 = b1 + b2;\t//编译不通过\n\t&#125;\n&#125;\nclass VariableTest4&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//1. 编码情况\n\t\tlong l = 123456;\n\t\tSystem.out.println(l);\n\t\t//编译失败：过大的整数\n\t\t//long l1 = 452367894586235;\n\t\tlong l1 = 452367894586235L;\n\n\t\t//**************************\n\t\t//编译失败\n//\t\tfloat f1 = 12.3;\n\t\t\n\t\t//2. 编码情况2:\n\t\t//整型变量，默认类型为int型\n\t\t//浮点型变量，默认类型为double型\n\t\tbyte b = 12;\n\t//\tbyte b1 = b + 1;\t//编译失败\n\t\t\n\t//\tfloat f1 = b + 12.3;\t//编译失败\n\t&#125;\n&#125;\n\n\nString\n\nString不是基本数据类型，属于引用数据类型\n使用方式与基本数据类型一致。例如：String str&#x3D; “abcd”;\n一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：\n\n/*\nString类型变量的使用\n1. String属于引用数据类型\n2. 声明String类型变量时，使用一对\"\"\n3. String可以和8种基本数据类型变量做运算，且运算只能是连接运算；+\n4. 运算的结果任然是String类型\n\n*/\nclass StringTest&#123;\n\tpublic static void main(String[] args)&#123;\n\n\t\tString s1 = \"Good Moon!\";\n\n\t\tSystem.out.println(s1);\n\n\t\tString s2 = \"a\";\n\t\tString s3 = \"\";\n\n//\t\tchar c = '';\t//编译不通过\n\t\t\n\t\t//*******************************\n\t\tint number = 1001;\n\t\tString numberStr = \"学号:\";\n\t\tString info = numberStr + number;\t//连接运算\n\t\tboolean b1 = true;\n\t\tString info1 = info + true;\n\t\tSystem.out.println(info1);\n\t&#125;\n&#125;\n\n\nString str1 = 4; //判断对错：no\nString str2 = 3.5f + “”; //判断str2对错：yes\nSystem.out.println(str2); //输出：”3.5”\nSystem.out.println(3+4+“Hello!”); //输出：7Hello!\nSystem.out.println(“Hello!”+3+4); //输出：Hello!34\nSystem.out.println(‘a’+1+“Hello!”); //输出：98Hello!\nSystem.out.println(“Hello”+‘a’+1); //输出：Helloa1\n\n\n3，强制类型转换\n自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。\n通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n如：String a = “43”; inti= Integer.parseInt(a);\nboolean类型不可以转换为其它的数据类型。\n\nshort s = 5;\ns = s-2; //判断：no\nbyte b = 3;\nb = b + 4;//判断：no\nb = (byte)(b+4);//判断：yes\nchar c = ‘a’;\nint i = 5;\nfloat d = .314F;\ndouble result = c+i+d; //判断：yes\nbyte b = 5;\nshort s = 3;\nshort t = s + b;//判断：no\n\n\n6，进制转换\n所有数字在计算机底层都以二进制形式存在。\n对于整数，有四种表示方式：\n二进制(binary)：0,1 ，满2进1.以0b或0B开头。\n十进制(decimal)：0-9 ，满10进1。\n八进制(octal)：0-7 ，满8进1. 以数字0开头表示。\n十六进制(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。如：0x21AF +1&#x3D; 0X21B0\n\n\n\nclass BinaryTest&#123;\n\tpublic static void main(String[] args)&#123;\n\n\t\tint num1 = 0b110;\n\t\tint num2 = 110;\n\t\tint num3 = 0127;\n\t\tint num4 = 0x110A;\n\n\t\tSystem.out.println(\"num1 = \" + num1);\n\t\tSystem.out.println(\"num2 = \" + num2);\n\t\tSystem.out.println(\"num3 = \" + num3);\n\t\tSystem.out.println(\"num4 = \" + num4);\n\t&#125;\n&#125;\n\n\n\n1，转十进制x进制转十进制：x进制的各个位数的数字y*x^（位数-1）后求和\n\n\n\n\n2，转二进制\n\n\n3，转十六进制\n\n4，转八进制\n5，原码反码补码\n正数：三码合一\n负数：原码反码之间头不变其他取反 反码补码之间+1反转-1 再用补码运算，转回原码赋值\n\n\n\n练习 2按位或3=？\n\n2的补码00000000 00000000 00000000 00000010\n\n3的补码00000000 00000000 00000000 00000011\n\n按位或计算后补码00000000 00000000 00000000 00000010\n\n原码00000000 00000000 00000000 00000011 结果为3\n\n练习2按位异或3=？\n\n2的补码00000000 00000000 00000000 00000010\n\n3的补码00000000 00000000 00000000 00000011\n\n 按位异或计算后补码00000000 00000000 00000000 000001\n\n 原码00000000 00000000 00000000 00000001结果为1\n\n\n6，位运算符\n\n\n练习 -1&lt;&lt;2=?\n\n-1原码10000000 00000000 00000000 00000001\n\n反码头不变11111111 11111111 11111111 11111110\n\n补码+1 11111111 11111111 11111111 11111111\n\n&lt;&lt;2计算补码 11111111 11111111 11111111 11111100\n\n反码-1 11111111 11111111 11111111 11111011\n\n原码头不变 10000000 00000000 00000000 00000100 结果-4\n\n\n/*\n运算符之五：位运算符(了解)\n\n结论：\n1.位运算符操作的都是整型的数据变量\n2.&lt;&lt; : 在一定范围内，每向左移一位，相当于 * 2\n  >> : 在一定范围内，每向右移一位，相当于 / 2\n\n面试题：最高效的计算2 * 8 ？\t2 &lt;&lt; 3 或 8 &lt;&lt; 1\n*/\nclass BitTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tint i = 21;\n//\t\ti = -21;\n\t\tSystem.out.println(\"i &lt;&lt; 2 :\" + (i &lt;&lt; 2));\n\t\tSystem.out.println(\"i &lt;&lt; 3 :\" + (i &lt;&lt; 3));\n\t\tSystem.out.println(\"i &lt;&lt; 20 :\" + (i &lt;&lt; 20));\n\t\tSystem.out.println(\"i &lt;&lt; 27 :\" + (i &lt;&lt; 27));\n\t\tint m = 12;\n\t\tint n = 5;\n\t\tSystem.out.println(\"m &amp; n :\" + (m &amp; n));\n\t\tSystem.out.println(\"m &amp; n :\" + (m | n));\n\t\tSystem.out.println(\"m &amp; n :\" + (m ^ n));\n\t\t//练习：交换两个变量的值\n\t\tint num1 = 10;\n\t\tint num2 = 20;\n\n\t\t//方式一：\n\t//\tint tent = num1;\n\t//\tnum1 = num2;\n\t//\tnum2 = tent;\n\n\t\t//方式二：\n\t\t//好处：不用定义临时变量\n\t\t//弊端：①相加可能超出存储范围 ② 有局限性：只适用于数值类型\n//\t\tnum1 = num1 + num2;\n//\t\tnum2 = num1 - num2;\n//\t\tnum1 = num1 - num2;\n\n\t\t//方式三：使用位运算\n\t\tnum1 = num1 ^ num2;\n\t\tnum2 = num1 ^ num2;\n\t\tnum1 = num1 ^ num2;\n\n\t\tSystem.out.println(\"num1 = \" + num1 + \",num2 = \" + num2);\n\t&#125;\n&#125;\n\n\n\n\n2，运算符\n\n\n\n\n\n\n\n\n是一种特殊的符号，用以表示数据的运算、赋值和比较等。\n\n算术运算符\n赋值运算符\n比较运算符（关系运算符）\n逻辑运算符\n位运算符\n三元运算符\n\n\n1，算术运算符/*\n运算符之一：算术运算符\n+ - * / % (前)++ (后)++ (前)-- (后)-- \n\n*/\nclass Day3Test&#123;\n\tpublic static void main(String[] args) &#123;\n\n\t\t//除号：/\n\t\tint num1 = 12;\n\t\tint num2 = 5;\n\t\tint resule1 = num1 / num2;\n\t\tSystem.out.println(resule1);\t//2\n\n\t\tint result2 = num1 / num2 * num2;\n\t\tSystem.out.println(result2);\n\n\t\tdouble result3 = num1 / num2;\n\t\tSystem.out.println(result3);\t//2.0\n\n\t\tdouble result4 = num1 / num2 + 0.0;\t//2.0\n\t\tdouble result5 = num1 / (num2 + 0.0);\t//2.4\n\t\tdouble result6 = (double)num1 / num2;\t//2.4\n\t\tdouble result7 = (double)(num1 / num2);\t//2.0\n\t\tSystem.out.println(result5);\n\t\tSystem.out.println(result6);\n\n\t\t// %：取余运算\n\t\t//结果的符号与被模数的符号相同\n\t\tint m1 = 12;\n\t\tint n1 = 5;\n\t\tSystem.out.println(\"m1 % n1 = \" + m1 % n1);\n\n\t\tint m2 = -12;\n\t\tint n2 = 5;\n\t\tSystem.out.println(\"m2 % n2 = \" + m2 % n2);\n\n\t\tint m3 = 12;\n\t\tint n3 = -5;\n\t\tSystem.out.println(\"m3 % n3 = \" + m3 % n3);\n\n\t\tint m4 = -12;\n\t\tint n4 = -5;\n\t\tSystem.out.println(\"m4 % n4 = \" + m4 % n4);\n\n\t\t//(前)++ : 先自增1，后运算\n\t\t//(后)++ ：先运算，后自增1\n\t\tint a1 = 10;\n\t\tint b1 = ++a1;\n\t\tSystem.out.println(\"a1 = \" + a1 + \",b1 = \" + b1);\n\n        int a2 = 10;\n\t\tint b2 = a2++;\n\t\tSystem.out.println(\"a2 = \" + a2 + \",b2 = \" + b2);\n\n\t\tint a3 = 10;\n\t\ta3++;\t//a3++;\n\t\tint b3 = a3;\n\n\t\t//注意点：\n\t\tshort s1 = 10;\n\t\t//s1 = s1 + 1;\t//编译失败\n//\t\ts1 = (short)(s1 + 1);\t//正确的\n\t\ts1++;\t//自增1不会改变本身变量的数据类型\n\t\tSystem.out.println(s1);\n\n\t\t//问题：\n\t\tbyte bb1 = 127;\n\t\tbb1++;\n\t\tSystem.out.println(\"bb1 = \" + bb1);\n\n\t\t//(前)-- :先自减1，后运算\n\t\t//(后)-- ：先运算，后自减1\n\n\t\tint a4 = 10;\n\t\tint b4 = a4--;\t//int b4 = --a4;\n\t\tSystem.out.println(\"a4 = \" + a4 + \",b4 = \" + b4);\n\t&#125;\n&#125;\n\n\n注意点如果对负数取模，可以把模数负号忽略不记，如：5%-2&#x3D;1。但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。对于除号“&#x2F;”，它的整数除和小数除是有区别的：整数之间做除法时，只保留整数部分而舍弃小数部分。例如：intx&#x3D;3510;x&#x3D;x&#x2F;1000*1000; x的结果是？“+”除字符串相加功能外，还能把非字符串转换成字符串.例如：System.out.println(“5+5&#x3D;”+5+5); &#x2F;&#x2F;打印结果是？5+5&#x3D;55 ?\n/*\n练习：随意给出一个三位数的整数，打印显是它的个位数，十位数，百位数的值。\n格式如下：\n数字xxx的情况如下：\n个位数：\n十位数：\n百位数：\n\n例如：\n数字153的情况如下：\n个位数：3\n十位数：5\n百位数：1\n\n*/\nclass AriExer&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tint num = 187;\n\t\tSystem.out.println(\"百位数：\" + num/100);\n\t\tSystem.out.println(\"十位数：\" + num%100/10);\n\t\tSystem.out.println(\"个位数：\" + num%10);\n\t&#125;\n&#125;\n\n\n2，赋值运算符\n符号：\n符号&#x3D;\n\n\n当“&#x3D;”两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理。\n支持连续赋值。\n\n\n扩展赋值运算符：+=, -=, *=, /=, %=\n\n\n/*\n运算符之二：赋值运算符\n+= -= *= /= \n\n*/\nclass SetValueTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//赋值符号：=\n\t\tint i1 = 10;\n\t\tint j1 = 10;\n\n\t\tint i2,j2;\n\t\t//连续赋值\n\t\ti2 = j2 = 10;\n\n\t\tint i3 = 10,j3 = 20;\n\n\t\t//***********************\n\t\tint num1 = 10;\n\t\tnum1 += 2;\t//num1 = num1 + 2;\n\t\tSystem.out.println(num1);\t//12\n\t\t\n\t\tint num2 = 12;\n\t\tnum2 %= 5;\t//num2 = num2 % 5;\n\t\tSystem.out.println(num2);\n\n\t\tshort s1 = 10;\n\t\t//s1 = s1 + 2;\t//编译失败\n\t\ts1 += 2;\t//结论：不会改变变量本身的数据类型\n\t\tSystem.out.println(s1);\n\n\t\t//开发中，如果希望变量实现+2的操作，有几种方法？？？(int num = 10)\n\t\t//方式一：num = num + 2;\n\t\t//方式二：num += 2;(推荐)\n\n\t\t//开发中，如果希望变量实现+1的操作，有几种方法？？？(int num = 10)\n\t\t//方式一：num = num + 1;\n\t\t//方式二：num += 1;\n\t\t//方式三：num++;(推荐)\n\t&#125;\n&#125;\n\n\n\nclass MkFan&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//练习1：\n\t\tint i = 1;\n\t\ti *= 0.1;\n\t\tSystem.out.println(i);//0\n\t\ti++;\n\t\tSystem.out.println(i);//1\n\n\t\t//练习2：\n\t\tint m = 2;\n\t\tint n1 = 3;\n\t\tn1 *= m++; \n\t\tSystem.out.println(\"m=\" + m);\t//3\n\t\tSystem.out.println(\"n1=\" + n1);\t//6\n\n\t\t//练习3：\n\t\tint n = 10;\n\t\tn += (n++) + (++n);\n\t\tSystem.out.println(n);\t//32\n\t&#125;\n&#125;\n\n\n3，比较运算符\n\n比较运算符的结果都是boolean型，也就是要么是true，要么是false。\n\n/*\n运算符之三：比较运算符\n==  !=  > &lt; >= &lt;= instanceof\n\n结论：\n1.比较运算符的结果是boolean类型\n2.区分 == 和 = \n\n*/\nclass CompareTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tint i = 10;\n\t\tint j = 20;\n\t\tSystem.out.println(i==j);\t//false\n        //比较运算符“`==`”不能误写成“=” 。\n\t\tSystem.out.println(i = j);\t//20\n\n\t\tboolean b1 = true;\n\t\tboolean b2 = false;\n\t\tSystem.out.println(b2 == b1);\t//false\n\t\tSystem.out.println(b2 = b1);\t//true\n\t&#125;\n&#125;\n\n\n4，逻辑运算符\n&amp;—逻辑与\n|—逻辑或\n！—逻辑非\n&amp;&amp; —短路与\n||—短路或\n^ —逻辑异或\n\n\n逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。“&amp;”和“&amp;&amp;”的区别：单&amp;时，左边无论真假，右边都进行运算；双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。左边为FALSE，右边执行异或(^)与或( | )的不同之处是：当左右都为true时，结果为false。理解：异或，追求的是“异”!\n/*\n运算符之四：逻辑运算符\n&amp; &amp;&amp; | || ！ ^\n\n说明：\n1. 逻辑与运算符操作的都是boolean类型的变量\n\n*/\nclass LogicTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//区分&amp; 与 &amp;&amp;\n\t\t//相同点1：&amp; 与 &amp;&amp; 的运算结果都相同\n\t\t//相同点2：当符号左边是true时，二者都会执行符号右边的运算\n\t\t//不同点：当符号左边是false时，&amp;继续执行符号\n\t\t//开发中，推荐使用&amp;&amp;\n\t\tboolean b1 = false;\n\t\tint num1 = 10;\n\t\tif(b1 &amp; (num1++ > 0))&#123;\n\t\t\tSystem.out.println(\"我现在在南京\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"我现在在北京\");//\n\t\t&#125;\n\t\tSystem.out.println(\"num1 = \" + num1);//左边为false，&amp;依旧执行右边为11\n\n\t\tboolean b2 = false;\n\t\tint num2 = 10;\n\t\tif(b2 &amp;&amp; (num2++ > 0))&#123;\n\t\t\tSystem.out.println(\"我现在在南京\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"我现在在北京\");\n\t\t&#125;\n\t\tSystem.out.println(\"num2 = \" + num2);//左边为false，&amp;&amp;不执行右边为10\n\n\t\t//区分：| 与 ||\n\t\t//相同点1：| 与 || 的运算结果都相同\n\t\t//相同点2：当符号左边是false时，二者都会执行符号右边的运算\n\t\t//不同点3：当符号左边是true时，|继续执行符号右边的运算，而||不再执行符号右边的运算\n\t\t//开发中，推荐使用||\n\t\tboolean b3 = true;\n\t\tint num3 = 10;\n\t\tif(b3 | (num3++ > 0))&#123;\n\t\t\tSystem.out.println(\"我现在在南京\");//true\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"我现在在北京\");\n\t\t&#125;\n\t\tSystem.out.println(\"num3 = \" + num3);//11\n\n\t\tboolean b4 = true;\n\t\tint num4 = 10;\n\t\tif(b4 || (num4++ > 0))&#123;\n\t\t\tSystem.out.println(\"我现在在南京\");//true\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"我现在在北京\");\n\t\t&#125;\n\t\tSystem.out.println(\"num4 = \" + num4);//10\n\t&#125;\n&#125;\n\n\nclass LogoinTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tboolean x = true;\n\t\tboolean y = false;\n\t\tshort z = 42;\n\t\t//if(y == true)\n\t\tif((z++==42)&amp;&amp;(y=true))z++;  //=是赋值\n\t\tif((x=false)||(++z==45)) z++;\n\t\tSystem.out.println(\"z=\" + z);\t//46\n\t&#125;\n&#125;\n\n\n\n\n5，三元运算符\n/*\n运算符之六：三元运算符\n1.结构：(条件表达式)？表达式1 : 表达式2\n2. 说明\n① 条件表达式的结果为boolean类型\n② 根据条件表达式真或假，决定执行表达式1，还是表达式2.\n  如果表达式为true,则执行表达式1\n  如果表达式为false,则执行表达式2\n③ 表达式1 和表达式2要求是一致的。\n④ 三元运算符是可以嵌套的\n3. 凡是可以使用三元运算的地方，都是可以改写if-else。\n   反之，则不一定成立！！！\n*/\nclass SanTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//获取两个整数的最大值\n\t\tint m = 12;\n\t\tint n = 5;\n\t\tint max = (m > n)? m : n;\n\t\tSystem.out.println(max);\n\n\t\tdouble num = (m > n) ? 2 : 1.0;//表达式1，和表达式2类型不一样\n\t\t//(m > n) ? 2 : \"n大\";\t//编译错误\n\n\t\t//****************************************\n\t\tString str = (m > n) ? \"m大\" : ((m == n)? \"m和n相等\" : \"n大\");//套娃娃\n\t\tSystem.out.println(str);\n\n\t\t//****************************************\n\t\t//获取三个数中的最大值\n\t\tint n1 = 12;\n\t\tint n2 = 30;\n\t\tint n3 = -43;\n\n\t\tint max1 = (n1 > n2) ? n1 : n2;\n\t\tint max2 = (max1 > n3) ? max1 : n3;\n\t\tSystem.out.println(\"三个数中的最大值是：\" + max2);\n\n\t\t//此方法：pass太繁琐\n\t\tint max3 = (((n1 > n2)? n1 : n2) > n3) ?((n1 > n2) ? n1 : n2) : n3;\n\t\tSystem.out.println(\"三个数中的最大值是：\" + max3);\n\n\t\t//改写成if-else\n\t\tif(m > n)&#123;\n\t\t\tSystem.out.println(m);\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(n);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n6，运算符的优先级\n运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如右表，上一行运算符总优先于下一行。\n只有单目运算符、三元运算符、赋值运算符是从右向左运算的。\n\n\n3，流程控制流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。\n其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：\n1，顺序结构：程序从上到下逐行地执行，中间没有任何判断和跳转。\n2，分支结构：根据条件，选择性地执行某段代码。有if…else和switch-case两种分支语句1， if-else结构条件表达式必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量；语句块只有一条执行语句时，一对{}可以省略，但建议保留；if-else语句结构，根据需要可以嵌套使用；当if-else结构是“多选一”时，最后的else是可选的，根据需要可以省略；当多个条件是“互斥”关系时，条件判断语句及执行语句间顺序无所谓当多个条件是“包含”关系时，“小上大下&#x2F; 子上父下”。\n\n\n/*\n分支结构中的if-else（条件判断结构）\n一、三种结构\n第一种：\nif(条件表达式)&#123;\n\t执行表达式\n&#125;\n第二种：\nif(条件表达式)&#123;\n\t执行表达式1\n&#125;else&#123;\n\t执行表达式2\n&#125;\n第三种：\nif(条件表达式)&#123;\n\t执行表达式1\n&#125;else if&#123;\n\t执行表达式2\n&#125;else if(条件表达式)&#123;\n\t执行表达式3\n&#125;\n...\nelse&#123;\n\t执行表达式n\n&#125;\n\n*/\nclass IfTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//举例1\n\t\tint heartBeats = 75;\n\t\tif(heartBeats &lt; 60 || heartBeats > 100)&#123;\n\t\t\tSystem.out.println(\"需要进一步做检查\");\n\t\t&#125;\n\t\tSystem.out.println(\"检查结束\");\n\n\t\t//举例2\n\t\tint age = 23;\n\t\tif(age &lt; 18)&#123;\n\t\t\tSystem.out.println(\"你还可以看动画片\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"你可以看科技电影了\");\n\t\t&#125;\n\n\t\t//举例3\n\t\tif(age &lt; 0)&#123;\n\t\t\tSystem.out.println(\"你输入的数据不合适\");\n\t\t&#125;else if(age &lt; 18)&#123;\n\t\t\tSystem.out.println(\"你还是个青少年\");\n\t\t&#125;else if(age &lt; 35)&#123;\n\t\t\tSystem.out.println(\"你还是个青壮年\");\n\t\t&#125;else if(age &lt; 60)&#123;\n\t\t\tSystem.out.println(\"你还是个中年\");\n\t\t&#125;else if(age &lt; 120)&#123;\n\t\t\tSystem.out.println(\"你进入老年了\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"你成仙了\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n2，switch-case结构switch结构中的表达式，只能是如下的六种数据类型之一：byte、short、char、int、枚举类型(JDK5.0)、String类型(JDK7.0)\n不能是：long，float，double，boolean。\n\n/*\n分支结构之二：switch-case\n\n1.格式\nswitch(表达式)&#123;\ncase 常量1:\n\t执行语句1;\n\t//break;\ncase 常量2:\n\t执行语句2;\n\t//break;\n\n...\n\ndefault:\n\t执行语句n:\n\t//break;\n&#125;\n\n2.说明:\n① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，进入相应case结构中，执行相关语句。\n  当调用完执行语句后，则仍然继续向下执行其他case语句，直到遇到break关键字或末尾结束为止。\n\n② break, 可以使用switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构。\n\n③ switch结构中的表达式，只能是如下的六种数据类型之一：byte、short、char、int、枚举类型(JDK5.0)、String类型(JDK7.0)\n④ case 之后之能声明常量。不能声明范围。\n\n⑤ break关键字是可选的。\n⑥ default：相当于if-else结构中的else。\n\t\t\tdefault 结构是可选的，而且位置是灵活的。\n*/\n\nclass SwitchTest&#123;\n\tpublic static void main(String[] args)&#123;\n\n\t\tint number = 2;\n\t\tswitch(number)&#123;\n\t\tcase 0:\n\t\t\tSystem.out.println(\"zero\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tSystem.out.println(\"one\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tSystem.out.println(\"twe\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(\"three\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"other\");\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t//*********************************\n\t\t//运行报错，不能运行boolean类型\n/*\t\tboolean isHandSome = true;\n\t\tswitch(isHandSome)&#123;\n\t\tcase true:\n\t\t\tSystem.out.println(\"可乐吗？？\");\n\t\t\tbreak;\n\t\tcase false:\n\t\t\tSystem.out.println(\"薯条吗？？\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"输入有误！！！\");\n\t\t&#125;\n*/\n\t\t//*********************************\n\t\tString season= \"summer\";\n\t\tswitch(season) &#123;\n\t\tcase\"spring\":\n\t\t\tSystem.out.println(\"春暖花开\");\n\t\t\tbreak;\n\t\tcase\"summer\":\n\t\t\tSystem.out.println(\"夏日炎炎\");\n\t\t\tbreak;\n\t\tcase\"autumn\":\n\t\t\tSystem.out.println(\"秋高气爽\");\n\t\t\tbreak;\n\t\tcase\"winter\":\n\t\t\tSystem.out.println(\"冬雪皑皑\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"季节输入有误\");\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t//**************************************\n\t\t//运行报错\n/*\t\tint age = 10;\n\t\tswitch(age)&#123;\t\t\t\n\t\tcase age > 18:\n\t\t\tSystem.out.println(\"成年了\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"未成年\");\n\t\t&#125;\t*/\n\t&#125;\n&#125;\n\n\n/*\n使用switch 把小写类型的char型转为大写。只转换a, b, c, d, e. 其它的输出“other”。\n提示：String word = scan.next();  char c = word.charAt(0); switch(c)&#123;&#125;\n*/\nimport java.util.Scanner;\nclass  SwitchCaseTest1&#123;\n\tpublic static void main(String[] args) &#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tString word = scan.next();  \n\t\tchar c = word.charAt(0); \n\t\tswitch(c)&#123;\n\t\tcase 'a':\n\t\t\tSystem.out.println(\"A\");\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tSystem.out.println(\"B\");\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tSystem.out.println(\"C\");\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tSystem.out.println(\"D\");\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tSystem.out.println(\"E\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"other\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。\n\n说明：如果switch-case语句中多个相同语句，可以进行合并。\n*/\nclass  SwitchTest1&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tint score = 78;\n\t\t//方案一\n\t\tswitch(score / 10)&#123;\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tSystem.out.println(\"不合格\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\n\t\tcase 9:\n\t\tcase 10:\n\t\t\tSystem.out.println(\"合格\");\n\t\t\tbreak;\n\t\t&#125;\n\n\t\t//更优的解法\n\t\tswitch(score /60)&#123;\n\t\tcase 0:\n\t\t\tSystem.out.println(\"不及格\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tSystem.out.println(\"合格\");\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n根据用于指定月份，打印该月份所属的季节。\n3,4,5 春季6,7,8 夏季9,10,11 秋季12, 1, 2 冬季\n\n*/\nclass MonthTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tint month = 6;\n\t\tswitch(month)&#123;\n\t\tcase 12:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tSystem.out.println(\"冬季\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tSystem.out.println(\"春季\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\tcase 8:\n\t\t\tSystem.out.println(\"夏季\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\tcase 10:\n\t\tcase 11:\n\t\t\tSystem.out.println(\"秋季\");\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n编写程序：从键盘上输入2020年的“month”和“day”，\n要求通过程序输出输入的日期为2019年的第几天。\n2 15 : 31 + 15\n\n5 7: 31 + 28 +31 +30 + 7\n...\n说明：break在switch-case中是可选的。\n*/\nimport java.util.Scanner;\nclass DayTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入2020年的month\");\n\t\tint month = scan.nextInt();\n\t\tSystem.out.println(\"请输入2020年的day\");\n\t\tint day = scan.nextInt();\n\n\t\t//定义一个变量来保存天数\n\t\tint sumDays = 0;\n\t\tswitch(month)&#123;\n\t\tcase 12:\n\t\t\tsumDays += 30;\n\t\tcase 11:\n\t\t\tsumDays += 31;\n\t\tcase 10:\n\t\t\tsumDays += 30;\n\t\tcase 9:\n\t\t\tsumDays += 31;\n\t\tcase 8:\n\t\t\tsumDays += 31;\n\t\tcase 7:\n\t\t\tsumDays += 30;\n\t\tcase 6:\n\t\t\tsumDays += 31;\n\t\tcase 5:\n\t\t\tsumDays += 30;\n\t\tcase 4:\n\t\t\tsumDays += 31;\n\t\tcase 3:\n\t\t\tsumDays += 29;\n\t\tcase 2:\n\t\t\tsumDays += 31;\n\t\tcase 1:\n\t\t\tsumDays += day;\n\t\t&#125;\n\n\t\tSystem.out.println(\"2020年\" + month + \"月\" + day + \"日是当年的第\" + sumDays + \"天\");\n\t&#125;\n&#125;\n\n\n/*\n从键盘分别输入年、月、日，判断这一天是当年的第几天注：判断一年是否是闰年的标准：\n1）可以被4整除，但不可被100整除或\n2）可以被400整除\n(year % 4 == 0 &amp;&amp; year % 100 != 0) || year %400 == 0)\n\n说明:\n1凡是可以使用switch-case的结构,都可以转换为if-else。反之,不成立。\n2.我们写分支结构时,当发现既可以使用switch-case,〔(同时,switch中表达式的取值情况不太多),\n又可以使用，我们优先选择使用switch-case。原因:switch-case执行效率稍高。\n\n*/\nimport java.util.Scanner;\nclass YearDayTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入year\");\n\t\tint year = scan.nextInt();\n\t\tSystem.out.println(\"请输入month\");\n\t\tint month = scan.nextInt();\n\t\tSystem.out.println(\"请输入day\");\n\t\tint day = scan.nextInt();\n\n\t\t//定义一个变量来保存天数\n\t\tint sumDays = 0;\n\t\tswitch(month)&#123;\n\t\tcase 12:\n\t\t\tsumDays += 30;\n\t\tcase 11:\n\t\t\tsumDays += 31;\n\t\tcase 10:\n\t\t\tsumDays += 30;\n\t\tcase 9:\n\t\t\tsumDays += 31;\n\t\tcase 8:\n\t\t\tsumDays += 31;\n\t\tcase 7:\n\t\t\tsumDays += 30;\n\t\tcase 6:\n\t\t\tsumDays += 31;\n\t\tcase 5:\n\t\t\tsumDays += 30;\n\t\tcase 4:\n\t\t\tsumDays += 31;\n\t\tcase 3:\n\t\t\t//判断是否为闰年\n\t\t\tif((year % 4 == 0 &amp;&amp; year % 100 != 0) || year %400 == 0)&#123;\n\t\t\t\tsumDays += 29;\n\t\t\t&#125;else&#123;\n\t\t\t\tsumDays += 28;\n\t\t\t&#125;\n\t\tcase 2:\n\t\t\tsumDays += 31;\n\t\tcase 1:\n\t\t\tsumDays += day;\n\t\t&#125;\n\n\t\tSystem.out.println(year + \"年\" + month + \"月\" + day + \"日是当年的第\" + sumDays + \"天\");\n\t&#125;\n&#125;\n\n\n/*\n编写一个程序，为一个给定的年份找出其对应的中国生肖。\n中国的生肖基于12年一个周期，每年用一个动物代表：\nrat、ox、tiger、rabbit、dragon、snake、horse、sheep、monkey、rooster、dog、pig。\n提示：2019年：猪2019 % 12 == 3\n*/\nimport java.util.Scanner;\nclass ZodiacSignTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入年份：\");\n\t\tint year = scan.nextInt();\n\t\tswitch (year % 12)&#123;\n\t\tcase 1:\n\t\t\tSystem.out.println(\"rooster\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tSystem.out.println(\"dog\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(\"pig\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tSystem.out.println(\"rat\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tSystem.out.println(\"ox\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tSystem.out.println(\"tiger\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tSystem.out.println(\"rabbit\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tSystem.out.println(\"dragon\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tSystem.out.println(\"snake\");\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tSystem.out.println(\"horse\");\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tSystem.out.println(\"sheep\");\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tSystem.out.println(\"monkey\");\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n编写一个程序，为一个给定的年份找出其对应的中国生肖。\n中国的生肖基于12年一个周期，每年用一个动物代表：\nrat、ox、tiger、rabbit、dragon、snake、horse、sheep、monkey、rooster、dog、pig。\n提示：2019年：猪2019 % 12 == 3\n*/\nimport java.util.Scanner;\nclass ZodiacSignTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入年份：\");\n\t\tint year = scan.nextInt();\n\t\tswitch (year % 12)&#123;\n\t\tcase 1:\n\t\t\tSystem.out.println(\"rooster\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tSystem.out.println(\"dog\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(\"pig\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tSystem.out.println(\"rat\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tSystem.out.println(\"ox\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tSystem.out.println(\"tiger\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tSystem.out.println(\"rabbit\");\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tSystem.out.println(\"dragon\");\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tSystem.out.println(\"snake\");\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tSystem.out.println(\"horse\");\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tSystem.out.println(\"sheep\");\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tSystem.out.println(\"monkey\");\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n3，循环结构1,for循环根据循环条件，重复性的执行某段代码。有while、do…while、for三种循环语句。JDK1.5提供了foreach循环，方便的遍历集合、数组元素。\n语法格式\nfor(①初始化部分;②循环条件部分;④迭代部分)｛\n            ③循环体部分;\n｝\n\n\n执行过程：①-②-③-④-②-③-④-②-③-④-.....-②\n\n\n说明：\n②循环条件部分为boolean类型表达式，当值为false时，退出循环\n①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔\n④可以有多个变量更新，用逗号分隔\n\n\n\n/*\nFor循环结构的使用\n一、循环结构的四个要素\n① 初始化条件\n② 循环条件\n③ 循环体\n④ 迭代条件\n\n二、for循环的结构\nfor(①;②;④)&#123;\n\t③\n&#125;\n*/\nclass ForTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i=1;i &lt;= 5 ;i++)&#123;\n\t\t\tSystem.out.println(\"Hello World!\");\n\t\t&#125;\n\n\t\t//练习：\n\t\tint num = 1;\n\t\tfor(System.out.print('a');num &lt;= 3;System.out.print('c'),num++)&#123;\n\t\t\tSystem.out.print('b');\n\t\t&#125;\n\n\t\t//遍历100以内的偶数,获取所有偶数的和,输出偶数的个数\n\t\tint sum = 0;\t//记录所有偶数的和\n\t\tint count = 0;\n\t\tfor(int i = 1;i &lt;= 100;i++)&#123;\n\t\t\tif(i %2 == 0)&#123;\n\t\t\t\tSystem.out.println(i);\n\t\t\t\tsum += i;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(\"100以内的偶数的和：\" + sum);\n\t\tSystem.out.println(\"个数为：\" + count);\n\t&#125;\n&#125;\n\n\n/*\n编写程序从1循环到150，并在每行打印一个值，\n另外在每个3的倍数行上打印出“foo”,\n在每个5的倍数行上打印“biz”,\n在每个7的倍数行上打印输出“baz”。\n\n*/\nclass ForTest1&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t\n\t\tfor(int i = 1;i &lt;= 150;i++ )&#123;\n\t\t\tSystem.out.print(i + \" \");\n\t\t\tif(i % 3 == 0)&#123;\n\t\t\t\tSystem.out.print(\"foo \");\n\t\t\t&#125;\n\t\t\tif(i % 5 == 0)&#123;\n\t\t\t\tSystem.out.print(\"biz \");\n\t\t\t&#125;\n\t\t\tif(i % 7 == 0)&#123;\n\t\t\t\tSystem.out.print(\"baz \");\n\t\t\t&#125;\n\n\t\t\t//换行\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n输入两个正整数m和n，求其最大公约数和最小公倍数。\n比如：12和20的最大公约数是4，最小公倍数是60。说明：break关键字的使用\n\n*/\nimport java.util.Scanner;\nclass GnumberTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.println(\"请输入m:\");\n\t\tint m = scan.nextInt();\n\t\tSystem.out.println(\"请输入n:\");\n\t\tint n = scan.nextInt();\n\t\t//获取m和n的较大值\n\t\tint max = (m > n) ? m : n;\n\t\t//获取m和n的最小值\n\t\tint min = (m &lt; n) ? m : n;\n\t\t\n\t\t//求最大公约数\n\t\tfor(int i = min;i >= 1;i--)&#123;\n\t\t\tif(m % i == 0 &amp;&amp; n % i == 0)&#123;\n\t\t\t\tSystem.out.println(\"m和n的最大公约数：\" + i);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\n\t\t//求最小公倍数\n\t\tfor(int i = max;i &lt;= m * n;i++)&#123;\n\t\t\tif( i % m == 0 &amp;&amp; i % n == 0)&#123;\n\t\t\t\tSystem.out.println(\"m和n的最小公倍数是：\" + i);\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。\n例如：153 = 1*1*1 + 3*3*3 + 5*5*5\n\n*/\nclass ForTest2&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tfor(int i = 100;i &lt;= 999;i++)&#123;\n\t\t\tint a = i / 100;\t//获取百位\n\t\t\tint b = i % 100 /10;\t//获取十位\n\t\t\tint c = i % 10;\t//获取个位\n\t\t\tif(a*a*a + b*b*b + c*c*c == i)&#123;\n\t\t\t\tSystem.out.println(\"此数值为满足条件的水仙花数:\" + i);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n2,while循环①-②-③-④-②-③-④-②-③-④-…-②\n①初始化部分\nwhile(②循环条件部分)｛\n    ③循环体部分;\n    ④迭代部分;\n&#125;\n必须声明④迭代部分。否则，循环将不能结束，变成死循环。\nfor循环和while循环可以相互转换。\n\npublic class WhileLoop &#123;\n    public static void main(String args[]) &#123;\n        int result = 0;\n        int i= 1;\n        while(i&lt;= 100) &#123;\n            result += i;\n            i++;\n        &#125;\n        System.out.println(\"result=\"+ result);\n    &#125;\n&#125;\n\n\n/*\nWhile循环结构的使用\n一、循环结构的四个要素\n① 初始化条件\n② 循环条件\n③ 循环体\n④ 迭代条件\n\n二、while循环的结构\n①初始化部分\nwhile(②循环条件部分)｛\n    ③循环体部分;\n    ④迭代部分;\n&#125;\n\n执行过程： ① - ② - ③ - ④ - ② -  ③ - ④ - ... - ② \n\n说明：\n1.写while循环千万要小心不要丢了迭代条件。一旦丢了，就可能导致死循环！\n2.写程序要避免死循环。\n3.能用while循环的，可以用for循环，反之亦然。二者可以相互转换。\n区别：for循环和while循环的初始化条件部分的作用范围不同。\n\n算法：有限性。\n*/\nclass WhileTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//遍历100以内的所有偶数\n\t\tint i = 1;\n\t\twhile(i &lt;= 100)&#123;\n\t\t\tif(i % 2 == 0)&#123;\n\t\t\t\tSystem.out.println(i);\n\t\t\t&#125;\n\t\t\ti++;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n3,do-while循环do-while循环结构的使用\n一、循环结构的四个要素\n① 初始化条件\n② 循环条件 --->是boolean类型\n③ 循环体\n④ 迭代条件\n\n二、do-while循环的结构\n①\ndo&#123;\n\t③;\n\t④;\n&#125;while(②);\n\n执行过程：① - ③ - ④ - ② - ① - ③ - ④ - ... - ②\n \n说明：do-while循环至少执行一次循环体。\n\n\nclass DoWhileTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t//遍历100以内的所有偶数,并计算所有偶数的和和偶数的个数\n\t\tint number = 1;\n\t\tint sum = 0;\t//记录总和\n\t\tint count = 0;\t//记录个数\n\t\tdo&#123;\n\t\t\tif(number % 2 == 0)&#123;\n\t\t\t\tSystem.out.println(number);\n\t\t\t\tsum += number;\n\t\t\t\tcount++;\n\t\t\t&#125;\n\t\t\tnumber++;\n\t\t&#125;while(number &lt;= 100);\n\n\t\tSystem.out.println(\"总和为：\" + sum);\n\t\tSystem.out.println(\"个数为：\" + count);\n\n\t\t//*********************************\n\t\tint numb = 10;\n\t\twhile(numb > 10)&#123;\n\t\t\tSystem.out.println(\"hello:while\");\n\t\t\tnumb--;\n\t\t&#125;\n\n        //只执行一次\n\t\tint numb2 = 10;\n\t\tdo&#123;\n\t\t\tSystem.out.println(\"hello：do-while\");\n\t\t\tnumb2--;\n\t\t&#125;while(numb2 > 10);\n\t&#125;\n&#125;\n\n\n/*\n从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。\n\n说明：\n1.不在循环条件部分限制次数的结构：while(true) , for(true)\n2.结束循环的几种方式：\n\t方式一：循环条件部分返回false;\n\t方式二：在循环体中，执行break;\n*/\nimport java.util.Scanner;\nclass XunTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\tScanner scan = new Scanner(System.in);\n\t\tint Positive = 0;\t//正数个数\n\t\tint Negative = 0;\t//负数个数\n\t\twhile(true)&#123;\n\t\t\tint number = scan.nextInt();\n\t\t\tif(number > 0)&#123;\n\t\t\t\tPositive++;\n\t\t\t&#125;else if(number &lt; 0)&#123;\n\t\t\t\tNegative++;\n\t\t\t&#125;else&#123;\n\t\t\t\t//一旦执行，跳出循环。\n\t\t\t\tbreak;\n\t\t\t&#125;\t\n\t\t&#125;\n\n\t\tSystem.out.println(\"正数的个数：\" + Positive);\n\t\tSystem.out.println(\"负数的个数：\" + Negative);\n\t&#125;\n&#125;\n\n\n4，嵌套结构将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while均可以作为外层循环或内层循环。实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环。设外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次\n/*\n嵌套循环的使用\n1.嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中，就构成了嵌套循环\n\n2.\n外层循环：循环结构B\n内层循环：循环结构A\n3.说明\n① 内层循环遍历一遍，只相当于外层循环循环体执行了一次\n② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次\n\n4.技巧\n外层循环控制行数，内层循环控制列数\n*/\nclass  ForForTest&#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//******\n\t\tfor(int i = 1;i &lt;= 6;i++)&#123;\n\t\t\tSystem.out.print(\"*\");\n\t\t&#125;\n\t\tSystem.out.println();//换行\n\n\t\t/*\n\t\t******\n\t\t******\n\t\t******\n\t\t******\n\t\t*/\n\t\tfor(int i = 1;i &lt;= 4;i++)&#123;  \n\t\t\tfor(int j = 1;j &lt;= 6;j++)&#123;  \n\t\t\t\tSystem.out.print('*');\n\t\t\t&#125;\n\t\t\tSystem.out.println();\t//换行\n\t\t&#125;\n\t\t/*\n\t\t*\n\t\t**\n\t\t***\n\t\t****\n\t\t*****\n\t\t*/\n\t\tfor(int i = 1;i &lt;= 5;i++)&#123;  //控制行数\n\t\t\tfor(int j = 1;j &lt;= i;j++)&#123;  //控制列数\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t\t/*\n\t\t*****\n\t\t****\n\t\t***\n\t\t**\n\t\t*\n\t\t*/\n\t\tfor(int i = 1;i &lt;= 6;i++)&#123;\n\t\t\tfor(int j = 1;j &lt;= 6-i;j++)&#123;\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\n\t\t/*\n\t\t*\n\t\t**\n\t\t***\n\t\t****\n\t\t*****\n\t\t****\n\t\t***\n\t\t**\n\t\t*\n\t\t*/\n\t\tfor(int i = 1;i &lt;= 5;i++)&#123;\n\t\t\tfor(int j = 1;j &lt;= i;j++)&#123;\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\n\t\tfor(int i = 1;i &lt;= 5;i++)&#123;\n\t\t\tfor(int j = 1;j &lt;= 5-i;j++)&#123;\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\n\t\t//九九乘法表\n\t\tfor(int i = 1;i &lt;= 9;i++)&#123;\n\t\t\tfor(int j = 1;j &lt;= i;j++)&#123;\n\t\t\t\tSystem.out.print(i + \"*\" + j + \"=\" + i*j + \" \");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\t//换行\n\t\t&#125;\n\n\t&#125;\n&#125;\n\n\n/*\n100以内的所有质数\n质数：素数，只能被1和它本身整除的自然数。\n\n最小的质数是：2\n*/\nclass PrimeNuberTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tboolean isFlag = true;\t//标识是否被除尽，一旦除尽，修改其值。\n\n\t\tfor(int i = 2;i &lt;= 100;i++)&#123;\t//遍历100以内的自然数\n\t\t\tfor(int j =2;j &lt; i;j++)&#123;\t//j:被i去除\n\t\t\t\tif(i % j == 0)&#123;\t//i被j除尽\n\t\t\t\t\tisFlag = false;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif(isFlag == true)&#123;\n\t\t\t\tSystem.out.println(i);\n\t\t\t&#125;\n\n\t\t\t//重置isFlag\n\t\t\tisFlag = true;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n/*\n100000以内的所有质数\n质数：素数，只能被1和它本身整除的自然数。\n\n最小的质数是：2\n*/\n\nclass PrimeNuberTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\tboolean isFlag = true;\t//标识是否被除尽，一旦除尽，修改其值。\n\t\tint count = 0;\t//记录质数的个数\n\n\t\t//获取当前时间举例1970-01-01 00:00:00 的毫秒数\n\t\tlong start = System.currentTimeMillis();\n\n\t\tfor(int i = 2;i &lt;= 100000;i++)&#123;\t//遍历100以内的自然数\n\t\t\t//优化2：对本身是质数的自然数有效 5447---> 11\n\t\t//\tfor(int j =2;j &lt; i;j++)&#123;\t//j:被i去除\n\t\t\tfor(int j =2;j &lt;= Math.sqrt(i);j++)&#123;\t//j:被i去除\n\t\t\t\tif(i % j == 0)&#123;\t//i被j除尽\n\t\t\t\t\tisFlag = false;\n\t\t\t\t\tbreak;\t//优化一：只对本身非质数的自然数是有效的。\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif(isFlag == true)&#123;\n\t\t\t//\tSystem.out.println(i);\n\t\t\t\tcount++;\n\t\t\t&#125;\n\n\t\t\t//重置isFlag\n\t\t\tisFlag = true;\n\t\t&#125;\n\n\t\t//获取当前时间举例1970-01-01 00:00:00 的毫秒数\n\t\tlong end = System.currentTimeMillis();\n\n\n\t\tSystem.out.println(\"质数的个数:\" + count);\n\t\tSystem.out.println(\"所花费的时间为:\" + (end - start));\t//16843 --> 5447\t优化一\n\t&#125;\n&#125;\n\n\nbreak&#123;    \n\t......\n\tbreak;\n\t......\n&#125;\n终止于某个语句块执行\n    \n\n    \nbreak语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块  \n    \nlabel1:\t&#123;\t......\nlabel2:\t\t&#123;\t......\nlabel3:\t\t\t&#123;\t......\n\t\t\t\t\tbreak label2;\n\t\t\t\t\t......\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\ncontinuecontinue语句用于跳过其所在循环语句块的一次执行，继续下一次循环\ncontinue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环\ncontinue只能使用在循环结构中\n\nreturnreturn：并非专门用于结束循环的，它的功能是结束一个方法。当一个方法执行到一个return语句时，这个方法将被结束。与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内。4、特殊流程控制语句说明\nbreak只能用于switch语句和循环语句中。continue 只能用于循环语句中。二者功能类似，但continue是终止本次循环，break是终止本层循环。break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同于goto的。\n/*\nbreak和countinue关键字的使用\n\t\t\t\t使用范围\t\t\t循环中使用的作用(不同点)\t相同点\nbreak:\t\t\tswitch-case\t\t\t结束当前循环\t\t\t\t关键字后面不能声明执行语句\n\t\t\t\t循环结构中\n\n\ncountinue:\t\t循环结构中\t\t\t结束当次循环\t\t\t\t关键字后面不能声明执行语句\n\n*/\nclass BreakContinueTest&#123;\n\tpublic static void main(String[] args)&#123;\n\t\t\n\t\tfor(int i = 1;i &lt;= 10;i++)&#123;\n\t\t\tif(i % 4 == 0)&#123;\n\t\t\t//\tbreak;\t//1、2、3\n\t\t\t\tcontinue;\t//1、2、3、5、6、7、9、10\n\t\t\t//\tSystem.out.println(\"该吃饭了！！！\");\n\t\t\t&#125;\n\t\t//\tSystem.out.println(i);\n\t\t&#125;\n\t\t//********************************\n\t\tfor(int i = 1;i &lt;= 4;i++)&#123;\n\t\t\t\n\t\t\t\tfor(int j = 1;j &lt;= 10; j++)&#123;\n\t\t\t\t\tif(i % 4 == 0)&#123;\n\t\t\t\t//\t\tbreak;\t//默认跳出包裹此关键字最近的一层的循环\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t&#125;\n\t\t\t\t\tSystem.out.print(j);\n\t\t\t\t&#125;\n\t\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n4，数组1，一维数组&#x2F;*\n * 一、数组的概述\n * 1.数组的理解：数组(Array)，是多个相同类型数据按一定顺序排列的集合，\n * 并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n * \n * 2.数组的相关概念：\n * &gt;数组名\n * &gt;元素\n * &gt;角标、下标、索引\n * &gt;数组的长度：元素的个数\n * \n * 3.数组的特点：\n * 1)数组属于引用类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型。\n * 2)创建数组对象会在内存中开辟一整块连续的空间；\n * 3)数组的长度一旦确定，就不能修改;\n * 4)数组是有序排列的。\n * \n * 4.数组的分类：\n * \t① 按照维数：一维数组、二维数组、三维数组……\n *  ② 按照数组元素类型：基本数据类型元素的数组、引用类型元素的数组\n *  \n *&#x2F;\npublic class ArrayTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\t&#x2F;&#x2F;1. 一维数组的声明和初始化\n\t\tint num;\t&#x2F;&#x2F;声明\n\t\tnum &#x3D; 10;\t&#x2F;&#x2F;初始化\n\t\tint id &#x3D; 1001;\t&#x2F;&#x2F;声明 + 初始化\n\t\t\n\t\tint[] ids;\t&#x2F;&#x2F;声明\n\t\t&#x2F;&#x2F;1.1静态初始化:数组的初始化和数组元素的赋值操作同时进行\n\t\tids &#x3D; new int[]&#123;1001,1002,1003,1004&#125;;\t\n\t\t&#x2F;&#x2F;1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行\n\t\tString[] names &#x3D; new String[5]; \n\t\t\n\t\t&#x2F;&#x2F;错误的写法：\n&#x2F;&#x2F;\t\tint[] arr1 &#x3D; new int[];\t&#x2F;&#x2F;未赋值、未指明长度\n&#x2F;&#x2F;\t\tint[5] arr2 &#x3D; new int[5];\n&#x2F;&#x2F;\t\tint[] arr3 &#x3D; new int[3]&#123;1,2,3&#125;;\n\t\t\n\t\t&#x2F;&#x2F;也是正确的写法：\n\t\tint[] arr7 &#x3D; &#123;1,2,3,5,4&#125;;&#x2F;&#x2F;类型推断\n\t\t\n\t\t&#x2F;*总结：数组一旦初始化完成，其长度就确定了。\n\t\t*&#x2F;\n\t\t\n\t\t&#x2F;&#x2F;2.如何调用数组的指定位置的元素：通过角标的方式调用。\n\t\t&#x2F;&#x2F;数组的角标(或索引)从0开始的，到数组的长度-1结束\n\t\tnames[0] &#x3D; &quot;张郃&quot;;\n\t\tnames[1] &#x3D; &quot;王陵&quot;;\n\t\tnames[2] &#x3D; &quot;张学良&quot;;\n\t\tnames[3] &#x3D; &quot;王传志&quot;;\t&#x2F;&#x2F;charAt(0)\n\t\tnames[4] &#x3D; &quot;李峰&quot;;\n&#x2F;&#x2F;\t\tnames[5] &#x3D; &quot;周礼&quot;;\t&#x2F;&#x2F;如果数组超过角标会通过编译，运行失败。\n\t\t\n\t\t&#x2F;&#x2F;3.如何获取数组的长度\n\t\t&#x2F;&#x2F;属性：length\n\t\tSystem.out.println(names.length);\t&#x2F;&#x2F;5\n\t\tSystem.out.println(ids.length);\t&#x2F;&#x2F;4\n\t\t\n\t\t&#x2F;&#x2F;4.如何遍历数组\n&#x2F;&#x2F;\t\tSystem.out.println(names[0]);\n&#x2F;&#x2F;\t\tSystem.out.println(names[1]);\n&#x2F;&#x2F;\t\tSystem.out.println(names[2]);\n&#x2F;&#x2F;\t\tSystem.out.println(names[3]);\n&#x2F;&#x2F;\t\tSystem.out.println(names[4]);\n\t\t\n\t\tfor(int i &#x3D; 0;i &lt; names.length;i++)&#123;\n\t\t\tSystem.out.println(names[i]);\n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n\n/*\n * ⑤ 数组元素的默认初始化值\n * \t\t> 数组元素是整形：0\n * \t\t> 数组元素是浮点型：0.0\n * \t\t> 数组元素是char型：0或'\\u0000'，而非'0'\n * \t\t> 数组元素是boolean型:false\n * \n * \t\t> 数组元素是引用数据类型：null \n */\npublic class ArrayTest1 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//5.数组元素的默认初始化值\n\t\tint[] arr = new int[4];\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tSystem.out.println(arr[i]);\n\t\t&#125;\n\t\tSystem.out.println(\"*****************\");\n\t\t\n\t\tshort[] arr1 = new short[4];\n\t\tfor(int i = 0;i &lt; arr1.length;i++)&#123;\n\t\t\tSystem.out.println(arr1[i]);\n\t\t&#125;\n\t\tSystem.out.println(\"*****************\");\n\t\t\n\t\tfloat[] arr2 = new float[5]; \n\t\tfor(int i = 0;i &lt; arr2.length;i++)&#123;\n\t\t\tSystem.out.println(arr2[i]);\n\t\t&#125;\n\t\tSystem.out.println(\"*****************\");\n\t\t\n\t\tchar[] arr3 = new char[5]; \n\t\tfor(int i = 0;i &lt; arr3.length;i++)&#123;\n\t\t\tSystem.out.println(\"----\" + arr3[i] + \"****\");\n\t\t&#125;\n\t\t\n\t\tif(arr3[0] == 0)&#123;\n\t\t\tSystem.out.println(\"你好！\");\n\t\t&#125;\n\t\tSystem.out.println(\"*****************\");\n\t\t\n\t\tboolean[] arr4 = new boolean[5];\n\t\tSystem.out.println(arr4[0]);\n\t\t\n\t\tSystem.out.println(\"*****************\");\n\t\tString[] arr5 = new String[5];\n\t\tSystem.out.println(arr5[0]);\n\t\t//验证\n\t\tif(arr5[0] == null)&#123;\n\t\t\tSystem.out.println(\"北京天气好差！\");\n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n\n1，内存结构\n2，内存解析\nint[] arr = new int[]&#123;1,2,3&#125;;\nString[] arr1 = new String[4];\narr1[1] = “刘德华”;\narr1[2] = “张学友”;\narr1 = new String[3];\nSystem.out.println(arr1[1]);//null\n数组内存解析完成，数组内部值为null。\n\n\n/*\n * 升景坊单间短期出租4个月，550元/月（水电煤公摊，网费35元/月），空调、卫生间、厨房齐全。\n * 屋内均是IT行业人士，喜欢安静。所以要求来租者最好是同行或者刚毕业的年轻人，爱干净、安静。\n * eclipse代码一键格式规范化：Ctrl+Shift+F\n */\npublic class ArrayDemo &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tint[] arr = new int[] &#123; 8, 2, 1, 0, 3 &#125;;\n\t\tint[] index = new int[] &#123; 2, 0, 3, 2, 4, 0, 1, 3, 2, 3, 3 &#125;;\n\t\tString tel = \"\";\n\t\tfor (int i = 0; i &lt; index.length; i++) &#123;\n\t\t\ttel += arr[index[i]];\n\t\t&#125;\n\t\tSystem.out.println(\"联系方式：\" + tel);\n\t&#125;\n&#125;\n\n\n/*\n * 2. 从键盘读入学生成绩，找出最高分，并输出学生成绩等级。\n * 成绩>=最高分-10    等级为’A’   \n * 成绩>=最高分-20    等级为’B’\n * 成绩>=最高分-30    等级为’C’   \n * 其余等级为’D’\n * 提示：先读入学生人数，根据人数创建int数组，存放学生成绩。\n */\nimport java.util.Scanner;\npublic class ArrayDemo2 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//1.使用Scanner，读取学生的个数\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.print(\"请输入学生人数：\");\n\t\tint num = scan.nextInt();\n\t\t\n\t\t//2.创建数组，存储学生成绩，动态初始化\n\t\tint[] str = new int[num];\n\t\tSystem.out.println(\"请输入\" + num + \"个学生成绩\");\n\t\t\t\t\n\t\t//3.给数组中的元素赋值\n\t\tint maxnum = 0;\n\t\tfor(int i = 0;i &lt; str.length;i++)&#123;\n\t\t\tstr[i] = scan.nextInt();\n\t\t\t//4.获取数组元素中的最大值：最高分\n\t\t\tif(maxnum &lt; str[i])&#123;\n\t\t\t\tmaxnum = str[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t//5.根据每个学生成绩与最高分的差值，得到每个学生的等级，并输出等级和成绩\t\n\t\tchar Grade;\t//成绩等级\n\t\tfor(int i = 0;i &lt; str.length;i++)&#123;\n\t\t\tif(maxnum - str[i] &lt;= 10)&#123;\n\t\t\t\tGrade = 'A';\n\t\t\t&#125;else if(maxnum - str[i] &lt;= 20)&#123;\n\t\t\t\tGrade = 'B';\n\t\t\t&#125;else if(maxnum - str[i] &lt;= 30)&#123;\n\t\t\t\tGrade = 'C';\n\t\t\t&#125;else&#123;\n\t\t\t\tGrade = 'D';\n\t\t\t&#125;\n\t\t\t\n\t\t\tSystem.out.println(\"student \" + i + \"score is\" + str[i] + \n\t\t\t\t\t\" grade is \" + Grade);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n2，多维数组相当于是一个表格，像下图Excel中的表格一样。\n\n//静态初始化\nint[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;\nint[] arr5[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;\nint[][] arr6 = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;\t\t\n\t\t\n//动态初始化\nString[][] arr2 = new String[3][2];\nString[][] arr3 = new String[3][];\narr3[1] = new String[4];\t//定义arr3的[1]为长度为4的字符数组\n\t\tSystem.out.println(arr3[1][0]);\n\n//调用数组的指定位置的元素\n\t\tSystem.out.println(arr1[0][1]);\t//2\n\t\tSystem.out.println(arr2[1][1]);\t//null\n//获取数组的长度\n\t\tSystem.out.println(arr4.length);\t//3\n\t\tSystem.out.println(arr4[0].length);\t//3\n\t\tSystem.out.println(arr4[1].length);\t//4\n//遍历二维数组\n\t\tfor(int i = 0;i &lt; arr4.length;i++)&#123;\n\t\t\tfor(int j = 0;j &lt; arr4[i].length;j++)&#123;\n\t\t\t\tSystem.out.print(arr4[i][j] + \" \");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t\n\n\n\n/*\n * 二维数组的使用：\n * \t规定：二维数组分为外层数组的元素，内层数组的元素\n * \tint[][] arr = new int[4][3]; \n *  外层元素:arr[0],arr[1]等\n *  内层元素:arr[0][0],arr[1][2]等\n *  \n * \t⑤ 数组元素的默认初始化值\n * \t针对于初始化方式一：比如：int[][] arr = new int[4][3];\n * \t\t外层元素的初始化值为：地址值\n * \t\t内层元素的初始化值为：与一维数组初始化情况相同\n * \t\n * 针对于初始化方式而：比如：int[][] arr = new int[4][];\n * \t\t外层元素的初始化值为：null\n * \t\t内层元素的初始化值为：不能调用，否则报错。\n * \n * \t⑥ 数组的内存解析\n */\npublic class ArrayTest3 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tint[][] arr = new int[4][3];\n\t\tSystem.out.println(arr[0]);\t//[I@15db9742\n\t\tSystem.out.println(arr[0][0]);\t//0\n\t\t\n//\t\tSystem.out.println(arr);\t//ArrayTest3.java\n\t\t\n\t\tSystem.out.println(\"***********************\");\n\t\tfloat[][] arr1 = new float[4][3];\n\t\tSystem.out.println(arr1[0]);\t//地址值\n\t\tSystem.out.println(arr1[0][0]);\t//0.0\n\t\t\n\t\tSystem.out.println(\"***********************\");\n\t\t\n\t\tString[][] arr2 = new String[4][2];\n\t\tSystem.out.println(arr2[1]);\t//地址值\n\t\tSystem.out.println(arr2[1][1]);\t//null\n\t\t\n\t\tSystem.out.println(\"*********************\");\n\t\tdouble[][] arr3 = new double[4][];\n\t\tSystem.out.println(arr3[1]);\t//null\n//\t\tSystem.out.println(arr3[1][0]);\t//报错\n\t&#125;\n&#125;\n\n\n1,二维数组内存解析\nint[][] arr1 = new int[4][];\narr1[1] = new int[]&#123;1,2,3&#125;;\narr1[2] = new int[4];\narr1[2][1] = 30;\n\n\n\nint[][] arr = new int[3][];\narr[1] = new int[]&#123;1,2,3&#125;;\narr[2] = new int[3];\nSystem.out.println(arr[0]);//null\nSystem.out.println(arr[0][0]);//报异常\n\n\n\nint[][] arr1= new int[4][];\narr1[0] = new int[3];\narr1[1] = new int[]&#123;1,2,3&#125;;\narr1[0][2] = 5;\narr1 = new int[2][];\n\n\n\npublic class ArrayEver1 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tint[][] arr = new int[][]&#123;&#123;3,5,8&#125;,&#123;12,9&#125;,&#123;7,0,6,4&#125;&#125;;\n\t\tint sum = 0;\t//记录总和\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tfor(int j = 0;j &lt; arr[i].length;j++)&#123;\n\t\t\t\tsum += arr[i][j];\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(sum);\n\t&#125;\n&#125;\n\n\n\n/*\n * 【提示】\n * 1. 第一行有 1 个元素, 第 n 行有 n 个元素\n * 2. 每一行的第一个元素和最后一个元素都是 1\n * 3. 从第三行开始, 对于非第一个元素和最后一个元素的元素。\n * 即：yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j];\n */\npublic class ArrayEver2 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//1.声明并初始化二维数组\n\t\tint[][] arr = new int[10][];\n\t\t\n\t\t//2.给数组的元素赋值，遍历二维数组\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tarr[i] = new int[i+1];\n\t\t\t\n\t\t\t//2.1 给首末元素赋值\n\t\t\tarr[i][0]=arr[i][i]=1;\n\t\t\t//2.2 给每行的非首末元素赋值\n\t\t//\tif(i > 1)&#123;\n\t\t\tfor(int j = 1;j &lt; arr[i].length-1;j++)&#123;\n\t\t\t\t\tarr[i][j] = arr[i-1][j-1] + arr[i-1][j];\n\t\t\t\t&#125;\n\t\t//\t&#125;\n\t\n\t\t&#125;\n\t\t\n\t//\t3.遍历数组\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tfor(int j = 0;j &lt;arr[i].length;j++)&#123;\n\t\t\t\tSystem.out.print(arr[i][j] + \" \");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n\n\n创建一个长度为 6 的 int 型数组，要求取值为 1-30，同时元素值各不相同//此题只做了解，初学不必精通。\npublic class ArrayEver3 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t// 方式一：\n//\t\tint[] arr = new int[6];\n//\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;// [0,1) [0,30) [1,31)\n//\t\t\tarr[i] = (int) (Math.random() * 30) + 1;\n//\n//\t\t\tboolean flag = false;\n//\t\t\twhile (true) &#123;\n//\t\t\t\tfor (int j = 0; j &lt; i; j++) &#123;\n//\t\t\t\t\tif (arr[i] == arr[j]) &#123;\n//\t\t\t\t\t\tflag = true;\n//\t\t\t\t\t\tbreak;\n//\t\t\t\t\t&#125;\n//\t\t\t\t&#125;\n//\t\t\t\tif (flag) &#123;\n//\t\t\t\t\tarr[i] = (int) (Math.random() * 30) + 1;\n//\t\t\t\t\tflag = false;\n//\t\t\t\t\tcontinue;\n//\t\t\t\t&#125;\n//\t\t\t\tbreak;\n//\t\t\t&#125;\n//\t\t&#125;\n//\n//\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;\n//\t\t\tSystem.out.println(arr[i]);\n//\t\t&#125;\n\t\t// 方式二：\n\t\tint[] arr2 = new int[6];\n\t\tfor (int i = 0; i &lt; arr2.length; i++) &#123;// [0,1) [0,30) [1,31)\n\t\t\tarr2[i] = (int) (Math.random() * 30) + 1;\n\n\t\t\tfor (int j = 0; j &lt; i; j++) &#123;\n\t\t\t\tif (arr2[i] == arr2[j]) &#123;\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\tfor (int i = 0; i &lt; arr2.length; i++) &#123;\n\t\t\tSystem.out.println(arr2[i]);\n\t\t&#125;\n\t&#125;\n&#125;    \n\n\n2,常见算法import java.util.Scanner;\n/*\n * 此题了解！！！\n * \n * 回形数格式方阵的实现\n * 从键盘输入一个整数（1~20） \n * 则以该数字为矩阵的大小，把 1,2,3…n*n 的数字按照顺时针螺旋的形式填入其中。例如： 输入数字2，则程序输出： 1 2 \n * 4 3 \n * 输入数字 3，则程序输出：1 2 3 \n * 8 9 4 \n * 7 6 5 \n * 输入数字 4， 则程序输出： \n * 1   2   3   4\n * 12  13  14  5 \n * 11  16  15  6 \n * 10  9   8   7\n */\npublic class ArrayTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tScanner scanner = new Scanner(System.in);\n\t\tSystem.out.println(\"输入一个数字:\");\n\t\tint len = scanner.nextInt();\n\t\tint[][] arr = new int[len][len];\n\t\tint s = len * len;\n\t\t/*\n\t\t * k = 1:向右 k = 2:向下 k = 3:向左 k = 4:向上\n\t\t */\n\t\tint k = 1;\n\t\tint i = 0, j = 0;\n\t\tfor (int m = 1; m &lt;= s; m++) &#123;\n\t\t\tif (k == 1) &#123;\n\t\t\t\tif (j &lt; len &amp;&amp; arr[i][j] == 0) &#123;\n\t\t\t\t\tarr[i][j++] = m;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tk = 2;\n\t\t\t\t\ti++;\n\t\t\t\t\tj--;\n\t\t\t\t\tm--;\n\t\t\t\t&#125;\n\t\t\t&#125; else if (k == 2) &#123;\n\t\t\t\tif (i &lt; len &amp;&amp; arr[i][j] == 0) &#123;\n\t\t\t\t\tarr[i++][j] = m;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tk = 3;\n\t\t\t\t\ti--;\n\t\t\t\t\tj--;\n\t\t\t\t\tm--;\n\t\t\t\t&#125;\n\t\t\t&#125; else if (k == 3) &#123;\n\t\t\t\tif (j >= 0 &amp;&amp; arr[i][j] == 0) &#123;\n\t\t\t\t\tarr[i][j--] = m;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tk = 4;\n\t\t\t\t\ti--;\n\t\t\t\t\tj++;\n\t\t\t\t\tm--;\n\t\t\t\t&#125;\n\t\t\t&#125; else if (k == 4) &#123;\n\t\t\t\tif (i >= 0 &amp;&amp; arr[i][j] == 0) &#123;\n\t\t\t\t\tarr[i--][j] = m;\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tk = 1;\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tm--;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t// 遍历\n\t\tfor (int m = 0; m &lt; arr.length; m++) &#123;\n\t\t\tfor (int n = 0; n &lt; arr[m].length; n++) &#123;\n\t\t\t\tSystem.out.print(arr[m][n] + \"\\t\");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n * 算法的考察：求数值型数组中元素的最大值、最小值、平均数、总和等\n * \n * 定义一个 int 型的一维数组，包含 10 个元素，分别赋一些随机整数，\n * 然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。\n * 要求：所有随机数都是两位数。\n * \n * [10,99]\n * 公式：(int)(Math.random() * (99 - 10 + 1) + 10)\n */\npublic class ArrayTest1 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tint[] arr = new int[10];\n\t\t//数组赋值\n\t\tfor(int i = 0;i &lt;arr.length;i++)&#123;\n\t\t\tarr[i] = (int)(Math.random() * (99 - 10 + 1) + 10);\n\t\t&#125;\n\t\t\n\t\t//遍历\n\t\tfor(int i =0;i &lt; arr.length;i++)&#123;\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t&#125;\n\t\tSystem.out.println();\n\t\t\n\t\t//求数组元素的最大值\n\t\tint maxValue = arr[0];\n\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\n\t\t\tif(maxValue &lt; arr[i])&#123;\n\t\t\t\tmaxValue = arr[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(\"最大值：\" + maxValue);\n\t\t\n\t\t//求数组元素的最小值\n\t\tint minValue = arr[0];\n\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\n\t\t\tif(minValue > arr[i])&#123;\n\t\t\t\tminValue = arr[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(\"最小值：\" + minValue);\n\t\t\n\t\t//求数组元素的总和\n\t\tint sum = 0;\n\t\tfor(int i = 1;i &lt;arr.length;i++)&#123;\n\t\t\tsum += arr[i];\n\t\t&#125;\n\t\tSystem.out.println(\"总和：\" + sum);\n\t\t\n\t\t//求数组元素的平均数\n\t\tdouble avgVales = sum / arr.length;\n\t\tSystem.out.println(\"平均数：\" + avgVales);\t\t\n\t&#125;\n&#125;\n\n\n/*\n * 使用简单数组\n * (1)创建一个名为 ArrayTest 的类，在 main()方法中声明 array1 和 array2 两个变量，他们是 int[]类型的数组。\n * (2)使用大括号&#123;&#125;，把 array1 初始化为 8 个素数：2,3,5,7,11,13,17,19。\n * (3)显示 array1 的内容。\n * (4)赋值 array2 变量等于 array1，修改 array2 中的偶索引元素，使其等于索引值(如 array[0]=0,array[2]=2)。打印出 array1。\n */\npublic class ArrayTest2 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//声明 array1 和 array2 两个 int[]变量\n\t\tint[] array1,array2;\n\t\t//array1 初始化\n\t\tarray1 = new int[]&#123;2,3,5,7,11,13,17,19&#125;;\n\t\t\n\t\t//显示 array1 的内容==遍历。\n\t\tfor(int i = 0;i &lt; array1.length;i++)&#123;\n\t\t\tSystem.out.print(array1[i] + \"\\t\");\n\t\t&#125;\n\t\t\n\t\t//赋值 array2 变量等于 array1\n        //不能称作数组的复制。\n\t\tarray2 = array1;\n\t\t\n\t\t//修改 array2 中的偶索引元素，使其等于索引值(如 array[0]=0,array[2]=2)。\n\t\tfor(int i = 0;i &lt; array2.length;i++)&#123;\n\t\t\tif(i % 2 == 0)&#123;\n\t\t\t\tarray2[i] = i;\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println();\n\t\t\n\t\t//打印出 array1。\n\t\tfor(int i = 0;i &lt; array1.length;i++)&#123;\n\t\t\tSystem.out.print(array1[i] + \"\\t\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n上述 array1 和 array2 是什么关系\n\n实现 array2 对 array1 数组的复制\nint[] array1,array2;\narray1 = new int[]&#123;2,3,5,7,11,13,17,19&#125;;\n//数组的复制\narray2 = new int[array1.length];\nfor(int i = 0;i &lt; array2.length;i++)&#123;\n\tarray2[i] = array1[i];\n&#125;\n\n\n\n数组赋值，反转，查找\n/*\n * 算法的考察：数组的复制、反转、查找(线性查找、二分法查找)\n */\npublic class ArrayTest3 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\n\t\tString[] arr = new String[]&#123;\"SS\",\"QQ\",\"YY\",\"XX\",\"TT\",\"KK\",\"EE\",\"GG\"&#125;;\n\t\t\n\t\t//数组的复制\n\t\tString[] arr1 = new String[arr.length];\n\t\tfor(int i = 0;i &lt; arr1.length;i++)&#123;\n\t\t\tarr1[i] = arr[i];\n\t\t&#125;\n\t\t\n\t\t//数组的反转\n\t\t//方法一：\n//\t\tfor(int i = 0;i &lt; arr.length / 2;i++)&#123;\n//\t\t\tString temp = arr[i];\n//\t\t\tarr[i] = arr[arr.length - i - 1];\n//\t\t\tarr[arr.length - i - 1] = temp;\n//\t\t&#125;\n\t\t\n\t\t//方法二：\n\t\tfor(int i = 0,j = arr.length - 1;i &lt; j;i++,j--)&#123;\n\t\t\tString temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t&#125;\n\t\t\n\t\t//遍历\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tSystem.out.print(arr[i] + \"\\t\");\n\t\t&#125;\n\t\tSystem.out.println();\n\t\t\n\t\t//查找（或搜索）\n\t\t//线性查找\n\t\tString dest = \"BB\";\t//要查找的元素\n\t\tdest = \"CC\";\n\t\t\n\t\tboolean isFlag = true;\n\t\t\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tif(dest.equals(arr[i]))&#123;\n\t\t\t\tSystem.out.println(\"找到了指定元素，位置为：\" + i);\n\t\t\t\tisFlag = false;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\tif(isFlag)&#123;\n\t\t\tSystem.out.println(\"很遗憾，没找到！\");\n\t\t&#125;\n\t\t\n\t\t//二分法查找：\n\t\t\n\t&#125;\n&#125;\n\n\n\npublic class ArrayTest3 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//二分法查找：\n\t\t//前提：所要查找的数组必须有序\n\t\tint[] arr2 = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;;\n\t\t\n\t\tint dest1 = -34;\n\t\tint head = 0;\t//初始的首索引\n\t\tint end = arr2.length - 1;\t//初始的末索引\n\t\tboolean isFlag1 = true;\n\t\twhile(head &lt;= end)&#123;\n\t\t\tint middle = (head + end)/2;\n\t\t\t\n\t\t\tif(dest1 == arr2[middle])&#123;\n\t\t\t\tSystem.out.println(\"找到了指定元素，位置为：\" + middle);\n\t\t\t\tisFlag1 = false;\n\t\t\t\tbreak;\n\t\t\t&#125;else if(arr2[middle] > dest1)&#123;\n\t\t\t\tend = middle - 1;\n\t\t\t&#125;else&#123;\t//arr2[middle] &lt; dest1\n\t\t\t\thead = middle + 1;\n\t\t\t&#125;\t\n\t\t&#125;\n\t\t\n\t\tif(isFlag1)&#123;\n\t\t\tSystem.out.println(\"很遗憾，没找到！\");\n\t\t&#125;\t\t\n\t&#125;\n&#125;\n\n\n3,冒泡排序\n/*\n * 数组的冒泡排序的实现\n * \n */\npublic class BubbleSortTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tint[] arr = new int[]&#123;43,32,76,92,-65,85,71,-42&#125;;\n\t\t\n\t\t//冒泡排序\n\t\tfor(int i = 0;i &lt; arr.length - 1;i++)&#123;\n\t\t\t\n\t\t\tfor(int j = 0;j &lt; arr.length - 1 - i;j++)&#123;\n\t\t\t\t\n\t\t\t\tif(arr[j] > arr[j+1])&#123;\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[j+1];\n\t\t\t\t\tarr[j+1] = temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\tfor(int i = 0;i &lt; arr.length;i++)&#123;\n\t\t\tSystem.out.print(arr[i] + \"\\t\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n4,快速排序\n/**\n  * 快速排序\n  * 通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，\n  * 则分别对这两部分继续进行排序，直到整个序列有序。\n  *\n */\npublic class QuickSort &#123;\n\tprivate static void swap(int[] data, int i, int j) &#123;\n\t\tint temp = data[i];\n\t\tdata[i] = data[j];\n\t\tdata[j] = temp;\n\t&#125;\n\tprivate static void subSort(int[] data, int start, int end) &#123;\n\t\tif (start &lt; end) &#123;\n\t\t\tint base = data[start];\n\t\t\tint low = start;\n\t\t\tint high = end + 1;\n\t\t\twhile (true) &#123;\n\t\t\t\twhile (low &lt; end &amp;&amp; data[++low] - base &lt;= 0)\n\t\t\t\t\t;\n\t\t\t\twhile (high > start &amp;&amp; data[--high] - base >= 0)\n\t\t\t\t\t;\n\t\t\t\tif (low &lt; high) &#123;\n\t\t\t\t\tswap(data, low, high);\n\t\t\t\t&#125; else &#123;\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tswap(data, start, high);\n\t\t\t\n\t\t\tsubSort(data, start, high - 1);//递归调用\n\t\t\tsubSort(data, high + 1, end);\n\t\t&#125;\n\t&#125;\n\tpublic static void quickSort(int[] data)&#123;\n\t\tsubSort(data,0,data.length-1);\n\t&#125;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\tint[] data = &#123; 9, -16, 30, 23, -30, -49, 25, 21, 30 &#125;;\n\t\tSystem.out.println(\"排序之前：\\n\" + java.util.Arrays.toString(data));\n\t\tquickSort(data);\n\t\tSystem.out.println(\"排序之后：\\n\" + java.util.Arrays.toString(data));\n\t&#125;\n&#125;\n\n\n5,Arrays 工具类1\tboolean equals(int[] a,int[] b)\t判断两个数组是否相等。2\tString toString(int[] a)\t输出数组信息。3\tvoid fill(int[] a,int val)\t将指定值填充到数组之中。4\tvoid sort(int[] a)\t对数组进行排序。5\tint binarySearch(int[] a,int key)\t对排序后的数组进行二分法检索指定的值。\nimport java.util.Arrays;\n/*\n * java.util.Arrays:作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\n */\npublic class ArrayTest4 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\t//1.boolean equals(int[] a,int[] b)判断两个数组是否相等。\n\t\tint[] arr1 = new int[]&#123;1,2,3,4&#125;;\n\t\tint[] arr2 = new int[]&#123;1,2,9,3&#125;;\n\t\tboolean isEquals = Arrays.equals(arr1, arr2);\n\t\tSystem.out.println(isEquals);\n\t\t\n\t\t//2.String toString(int[] a)输出数组信息。\n\t\tSystem.out.println(Arrays.toString(arr1));\t\t\n\t\t\n\t\t//3.void fill(int[] a,int val)将指定值填充到数组之中。\n\t\tArrays.fill(arr1, 10);\n\t\tSystem.out.println(Arrays.toString(arr1));\t\t\n\t\t\n\t\t//4.void sort(int[] a)对数组进行排序。\n\t\tArrays.sort(arr2);\n\t\tSystem.out.println(Arrays.toString(arr2));\n\t\t\n\t\t//5.int binarySearch(int[] a,int key)对排序后的数组进行二分法检索指定的值。\n\t\tint[] arr3 = new int[]&#123;43,32,76,92,-65,85,71,-42&#125;; \n\t\tint index = Arrays.binarySearch(arr3, 210);\n\t\tif(index >= 0)&#123;\n\t\t\tSystem.out.println(index);\n\t\t&#125;else&#123;\n\t\t\tSystem.err.println(\"未找到。\");\n\t\t&#125;\t\t\n\t&#125;\n&#125;\n\n\n3，数组中常见异常/*\n * 数组中的常见异常：\n * 1.数组角标越界的异常:ArrayIndexOutOfBoundsException\n * \n * 2.空指针异常:NullPointerException\n * \n */\npublic class ArrayExceptionTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\t//1.数组角标越界的异常:ArrayIndexOutOfBoundsException\n\t\tint[] arr = new int[]&#123;1,2,3,4,5,6&#125;;\n\t\t\n\t\t//错误1：\n//\t\tfor(int i = 0;i &lt;= arr.length;i++)&#123;\n//\t\t\tSystem.out.println(arr[i]);\n//\t\t&#125;\n\t\t\n\t\t//错误2：\n//\t\tSystem.out.println(arr[-2]);\n\t\t\n\t\t//错误3\n//\t\tSystem.out.println(\"hello\");\n\t\t\n\t\t//2.空指针异常:NullPointerException\n\t\t//情况一:\n//\t\tint[] arr2= new int[]&#123;1,2,3&#125;;\n//\t\tarr2 = null;\n//\t\tSystem.out.println(arr2[0]);\n\t\t//情况二:\n//\t\tint[][] arr2 = new int[4][];\n//\t\tSystem.out.println(arr2[0][0]);\n\t\t\n\t\t//情况三:\n//\t\tString[] arr3 = new String[]&#123;\"AA\",\"QQ\",\"YY\",\"XX\",\"TT\",\"KK\"&#125;;\n//\t\tarr3[0] = null;\n//\t\tSystem.out.println(arr3[0].toString());\t\t\n\t&#125;\n&#125;\n\n\n3，面向对象11，面向过程(POP) 与面向对象(OOP)\n面向对象：Object Oriented Programming\n面向过程：Procedure Oriented Programming\n\n/*\n * 一、学习面向对象内容的三条主线\n * 1.Java 类及类的成员：属性、方法、构造器、代码块、内部类\n * 2.面向对象的三大特征：封装、继承、多态性、(抽象性)\n * 3.其它关键字：this、super、static、final、abstract、interface、package、import 等\n * \n * 二、人把大象装进冰箱\n * 1.面向过程:强调的是功能行为，以函数为最小单位，考虑怎么做。\n * \n * ① 打开冰箱\n * ② 把大象装进冰箱\n * ③ 把冰箱门关住 \n * \n * 2.面向对象:强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。\n * 人&#123;\n * \t\t打开(冰箱)&#123;\n * \t\t\t冰箱.开门();\n * \t\t&#125;操作(大象)&#123;\n * \t\t\t大象.进入(冰箱);\n * \t\t&#125;关闭(冰箱)&#123;\n * \t\t\t 冰箱.关门();     \n * \t\t&#125;\n * &#125;\n * \n * 冰箱&#123;\n * \t\t开门()&#123;\n * \t\t&#125;  \n * \t\t关门()&#123;\n * \t\t&#125;\n * &#125;\n * \n * 大象&#123;\n * \t\t进入(冰箱)&#123;\n * \t\t&#125;\n * &#125;\n */\n\n\n面向对象的思想概述\n程序员从面向过程的执行者转化成了面向对象的指挥者面向对象分析方法分析问题的思路和步骤：根据问题需要，选择问题所针对的现实世界中的实体。从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。\n2,类和对象/* \n * 三、面向对象的两个要素：\n * 类:对一类事物的描述，是抽象的、概念上的定义\n * 对象:是实际存在的该类事物的每个个体，因而也称为实\t例(instance)。\n * 可以理解为：类= 抽象概念的人；对象= 实实在在的某个人\n * 面向对象程序设计的重点是类的设计；\n * 设计类，其实就是设计类的成员。\n */\n\n\n1、Java 类及类的成员现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java 代码世界是由诸多个不同功能的类构成的。\n现实生物世界中的细胞又是由什么构成的呢？细胞核、细胞质、… 那么，Java 中用类 class 来描述事物也是如此。常见的类的成员有：\n属性：对应类中的成员变量行为：对应类中的成员方法\n\n2、类与对象的创建及使用/*\n * 一、设计类、其实就是设计类的成员\n * Field = 属性 = 成员变量 = 域、字段\n * Method = (成员)方法 = 函数 \n * \n * 创建类 = 类的实例化 = 实例化类\n * \n * 二.类和对象的使用(面向对象思想落地的实现)\n * 1.创建类，设计类的成员\n * 2.创建类的对象\n * 3.通过“对象.属性”或“对象.方法”调用对象的结构\n * 三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)\n * \t  意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。\n */\n//测试类\npublic class PersonTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//2.创建 Person 类的对象\n\t\t//创建对象语法：类名对象名= new 类名();\n\t\tPerson p1 = new Person();\n\t\t//Scanner scan = new Scanner(System.in);\n\t\t\n\t\t//调用类的结构：属性、方法\n\t\t//调用属性:“对象.属性”\n\t\tp1.name = \"Tom\";\n\t\tp1.age = 25;\n\t\tp1.isMale = true;\n\t\tSystem.out.println(p1.name);\n\t\t\n\t\t//调用方法:“对象.方法”\n\t\tp1.eat();\n\t\tp1.sleep();\n\t\tp1.talk(\"chinese\");\n\t\t//**********************\n\t\tPerson p2 = new Person();\n\t\tSystem.out.println(p2.name); //null\n\t\tSystem.out.println(p2.isMale);\n\t\t//**********************\n\t\t//将 p1 变量保存的对象地址值赋给 p3,导致 p1 和 p3 指向了堆空间中的一个对象实体。\n\t\tPerson p3 = p1;\n\t\tSystem.out.println(p3.name);\n\t\t\n\t\tp3.age = 10;\n\t\tSystem.out.println(p1.age); //10\n\t&#125;\n&#125;\n/*\n * 类的语法格式：\n * 修饰符 class 类名&#123;\n * \t\t属性声明;\n * \t\t方法声明;\n * &#125;\n * 说明：修饰符 public：类可以被任意访问类的正文要用&#123;  &#125;括起来\n */\n//1.创建类，设计类的成员\nclass Person&#123;\n\t\n\t//属性:对应类中的成员变量\n\tString name;\n\tint age;\n\tboolean isMale;\n\t\n\t//方法:对应类中的成员方法\n\tpublic void eat()&#123;\n\t\tSystem.out.println(\"吃饭\");\n\t&#125;\n\t\n\tpublic void sleep()&#123;\n\t\tSystem.out.println(\"睡觉\");\n\t&#125;\n\t\n\tpublic void talk(String language)&#123;\n\t\tSystem.out.println(\"人可以说话，使用的是：\" + language);\n\t&#125;\n&#125;\n\n\n3、对象的创建和使用：内存解析\n堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。\n栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放。\n方法区（MethodArea），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\nPerson p1= newPerson();\np1.name = \"Tom\";\np1.isMale = true;\nPerson p2 = new Person();\nsysout(p2.name);//null\nPerson p3 = p1;\np3.age = 10;\n\n\n\nPerson p1= newPerson();\np1.name = \"胡利民\";\np1.age = 23;\nPerson p2 = new Person();\np2.age = 10;\n\n\n1,类的成员之一：属性/*\n * 类中属性的使用\n * \n * 属性(成员变量)\tvs\t局部变量\n * 1.相同点:\n * \t\t1.1 定义变量的格式:数据类型 变量名 = 变量值\n * \t\t1.2 先声明，后使用\n * \t\t1.3 变量都有其对应的作用域\n * \t\t\t\t\n * 2.不同点:\n * \t\t2.1 在类中声明的位置不同\n * \t\t属性:直接定义在类的一对&#123;&#125;内\n * \t\t局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量\n * \n * \t\t2.2 关于权限修饰符的不同\n * \t\t属性:可以在声明属性时，指明其权限，使用权限修饰符。\n * \t\t\t常用的权限修饰符:private、public、缺省、protected\n * \t\t\t目前声明属性时，都使用缺省即可。\n * \t\t局部变量:不可以使用权限修饰符。\n * \n * \t\t2.3 默认初始化值的情况:\n * \t\t属性:类的属性，根据其类型，都有默认初始化值。\n * \t\t\t整型(byte、short、int、long):0\n * \t\t\t浮点型(float、double):0.0\n * \t\t\t字符型(char):0(或‘\\u0000’)\n * \t\t\t布尔型(boolean):false\n * \n * \t\t\t引用数据类型(类、数组、接口):null\n * \n * \t\t局部变量:没有默认初始化值\n * \t\t\t意味着:在调用局部变量之前，一定要显式赋值。\n * \t\t\t特别地:形参在调用时,赋值即可。例，45 行\n * \n * \t\t2.4 在内存中加载的位置，亦各不相同。\n * \t\t属性:加载到堆空间中(非 static)\n * \t\t局部变量:加载到栈空间\n */\npublic class UserTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tUser u1 = new User();\n\t\tSystem.out.println(u1.name);\n\t\tSystem.out.println(u1.age);\n\t\tSystem.out.println(u1.isMale);\n\t\t\n\t\tu1.talk(\"俄语\");\n\t&#125;\n&#125;\nclass User&#123;\n\t//属性(或成员变量)\n\tString name;\t//不加 private 即为缺省\n\tpublic int age;\t//不加 public 即为缺省\n\tboolean isMale;\n\t\n\tpublic void talk(String language)&#123;//language:形参，也是局部变量\n\t\tSystem.out.println(\"我们使用\" + language + \"进行交流。\");\n\t&#125;\n\t\n\tpublic void eat()&#123;\n\t\tString food = \"石头饼\";\t//石头饼:局部变量\n\t\tSystem.out.println(\"北方人喜欢吃:\" + food);\n\t&#125;\n&#125;\n\n\n/*\n编写教师类和学生类，并通过测试类创建对象进行测试\nStudent类\n属性:\nname:String age:int major:String interests:String\n方法:say() 返回学生的个人信息\nTeacher类\n属性:\nname:String age:int teachAge:int course:String\n方法:say() 输出教师的个人信息\n*/\npublic class School &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tStudent stu = new Student();\n        stu.name = \"小明\";\n        stu.age = 16;\n\t\t\n\t\tTeacher tea = new Teacher();\n\t\ttea.name = \"王老师\";\n        tea.age = 27;\n        \n        tea.say(stu.name,stu.age);\n        stu.say(tea.name, tea.age);\n\t&#125;\t\n&#125;\nclass Student&#123;\n\tString name;\n\tint age;\n\tString major;\n\tString interests;\n\t\n\tvoid say(String name, int age)&#123;\n\t\tSystem.out.println(\"这个学生是：\"+name+\"年龄是：\"+age);\t&#125;\n&#125;\nclass Teacher&#123;\n\tString name;\n\tint age;\n\tString teachAge;\n\tString course;\n\t\n\tvoid say(String name, int age)&#123;\n\t\tSystem.out.println(\"这个老师是：\"+name+\"年龄是：\"+age);\n\t&#125;\n&#125;\n\n\n2,类的成员之二：方法/*\n * 类中方法的声明和使用\n * \n * 方法：描述类应该具有的功能。\n * 比如：Math类：sqrt()\\random() \\...\n *     Scanner类：nextXxx() ...\n *     Arrays类：sort() \\ binarySearch() \\ toString() \\ equals() \\ ...\n * \n * 1.举例：\n * public void eat()&#123;&#125;\n * public void sleep(int hour)&#123;&#125;\n * public String getName()&#123;&#125;\n * public String getNation(String nation)&#123;&#125;\n * \n * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表)&#123;\n * \t\t\t\t\t方法体\n * \t\t\t  &#125;\n *   注意：static、final、abstract 来修饰的方法，后面再讲。\n *   \n * 3. 说明：\n * \t\t3.1 关于权限修饰符：默认方法的权限修饰符先都使用public\n * \t\t\tJava规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说\n * \n * \t\t3.2 返回值类型： 有返回值  vs 没有返回值\n * \t\t\t3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用\n *                return关键字来返回指定类型的变量或常量：“return 数据”。\n * \t\t\t\t  如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要\n *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。\n * \n * \t\t\t3.2.2 我们定义方法该不该有返回值？\n * \t\t\t\t① 题目要求\n * \t\t\t\t② 凭经验：具体问题具体分析\n * \n *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”\n *      3.4 形参列表:方法名可以声明0个、1个，或多个形参。\n *      \t3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...\n *      \n *      \t3.4.2 我们定义方法时，该不该定义形参？\n *      \t\t① 题目要求\n *      \t\t② 凭经验，具体问题具体分析\n *      3.5 方法体:方法功能的体现。\n *  4. return关键字的使用：\n *  \t1.使用范围:使用在方法体中\n *  \t2.作业:① 结束方法\n *  \t\t  ② 针对于有返回值类型的方法，使用\"return 数据\"方法返回所要的数据。\n *  \t3.注意点:return关键字后不可声明执行语句。\n *  5. 方法的使用中，可以调用当前类的属性或方法。\n *  \t\t特殊的:方法A中又调用了方法A:递归方法。\n *  \t方法中不能定义其他方法。\n */\npublic class CustomerTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tCustomer cust1 = new Customer();\n\t\t\n\t\tcust1.eat();\n\t\t\n\t\t//测试形参是否需要设置的问题\n//\t\tint[] arr = new int[]&#123;3,4,5,2,5&#125;;\n//\t\tcust1.sort();\n\t\t\n\t\tcust1.sleep(8);\n\t\t\n\t&#125;\n&#125;\n//客户类\nclass Customer&#123;\n\t\n\t//属性\n\tString name;\n\tint age;\n\tboolean isMale;\n\t\n\t//方法\n\tpublic void eat()&#123;\n\t\tSystem.out.println(\"客户吃饭\");\n\t\treturn;\n\t\t//return后不可以声明表达式\n//\t\tSystem.out.println(\"hello\");\n\t&#125;\n\t\n\tpublic void sleep(int hour)&#123;\n\t\tSystem.out.println(\"休息了\" + hour + \"个小时\");\n\t\t\n\t\teat();\n//\t\tsleep(10);\n\t&#125;\n\t\n\tpublic String getName()&#123;\n\t\t\n\t\tif(age > 18)&#123;\n\t\t\treturn name;\n\t\t\t\n\t\t&#125;else&#123;\n\t\t\treturn \"Tom\";\n\t\t&#125;\n\t&#125;\n\t\n\tpublic String getNation(String nation)&#123;\n\t\tString info = \"我的国籍是：\" + nation;\n\t\treturn info;\n\t&#125;\n\t\n\t//体会形参是否需要设置的问题\n//\tpublic void sort(int[] arr)&#123;\n//\t\t\n//\t&#125;\n//\tpublic void sort()&#123;\n//\t\tint[] arr = new int[]&#123;3,4,5,2,5,63,2,5&#125;;\n//\t\t//。。。。\n//\t&#125;\n\t\n\tpublic void info()&#123;\n\t\t//错误的\n//\t\tpublic void swim()&#123;\n//\t\t\t\n//\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n\n\npublic class Person &#123;\n\tString name;\n\tint age;\n\t/*\n\t * sex:1表示为男性\n\t * sex:0表示为女性\n\t */\n\tint sex;\n\t\n\tpublic void study()&#123;\n\t\tSystem.out.println(\"studying\");\n\t&#125;\n\t\n\tpublic void showAge()&#123;\n\t\tSystem.out.println(\"age:\" + age);\n\t&#125;\n\t\n\tpublic int addAge(int i)&#123;\n\t\tage += i;\n\t\treturn age;\n\t&#125;\n&#125;\n/*\n * 要求:\n * (1)创建Person类的对象，设置该对象的name、age和sex属性，\n * \t调用study方法，输出字符串“studying”，\n * \t调用showAge()方法显示age值，\n * \t调用addAge()方法给对象的age属性值增加2岁。\n * (2)创建第二个对象，执行上述操作，体会同一个类的不同对象之间的关系。\n * \n */\npublic class PersonTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tPerson p1 = new Person();\n\t\t\n\t\tp1.name = \"Tom\";\n\t\tp1.age = 18;\n\t\tp1.sex = 1;\n\t\t\n\t\tp1.study();\n\t\t\n\t\tp1.showAge();\n\t\t\n\t\tint newAge = p1.addAge(2);\n\t\tSystem.out.println(p1.name + \"的年龄为\" + newAge);\n\t\t\n\t\tSystem.out.println(p1.age);\t//20\n\t\t\n\t\t//*******************************\n\t\tPerson p2 = new Person();\n\t\tp2.showAge();\t//0\n\t\tp2.addAge(10);\n\t\tp2.showAge();\t//10\n\t\t\n\t\tp1.showAge();\t//20\n\t&#125;\n&#125;\n\n\n/*\n * 2.利用面向对象的编程方法，设计类Circle计算圆的面积。\n */\n//测试类\npublic class CircleTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tCircle c1 = new Circle();\n\t\t\n\t\tc1.radius = 2.1;\n\t\t\n\t\t//对应方式一:\n//\t\tdouble area = c1.findArea();\n//\t\tSystem.out.println(area);\n\t\t\n\t\t//对应方式二:\n\t\tc1.findArea();\n\t\t//错误的调用\n\t\tdouble area = c1.findArea(3.4);\n\t\tSystem.out.println(area);\n\t&#125;\n&#125;\n//圆:3.14*r*r\nclass Circle&#123;\n\t//属性\n\tdouble radius;\n\t\n\t//圆的面积方法\n\t//方法1：\n//\tpublic double findArea()&#123;\n//\t\tdouble area = 3.14 * radius * radius;\n//\t\treturn area;\n//\t&#125;\t\n\t//方法2：\n\tpublic void findArea()&#123;\n\t\tdouble area = Math.PI * radius * radius;\n\t\tSystem.out.println(\"面积为:\" + area);\n\t&#125;\n\t//错误情况:\n\tpublic double findArea(Double r)&#123;\n\t\tdouble area = 3.14 * r * r;\n\t\treturn area;\n\t&#125;\n&#125;\n\n\n/*\n * 3.1 编写程序，声明一个method方法，在方法中打印一个10*8的*型矩形，在main方法中调用该方法。\n * 3.2修改上一个程序，在method方法中，除打印一个10*8的*型矩形外，再计算该矩形的面积，\n * 并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。\n * \n * 3.3 修改上一个程序，在method方法提供m和n两个参数，方法中打印一个m*n的*型矩形，\n * 并计算该矩形的面积，将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印。\n * \n */\npublic class ExerTest &#123;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tExerTest esr = new ExerTest();\n\t\t//3.1测试\n//\t\tesr.method();\n\t\t\n\t\t//3.2测试\n\t\t//方式一：\n//\t\tint area = esr.method();\n//\t\tSystem.out.println(\"面积为:\" + area);\n\t\t\n\t\t//方式二:\n//\t\tSystem.out.println(\"面积为:\" + esr.method());\n\t\t\n\t\t//3.3测试\n\t\tSystem.out.println(\"面积为:\" + esr.method(6,5));\n\t&#125;\n\t//3.1\n//\tpublic void method()&#123;\n//\t\tfor(int i = 0;i &lt; 10;i++)&#123;\n//\t\t\tfor(int j = 0;j &lt; 8;j++)&#123;\n//\t\t\t\tSystem.out.print(\"* \");\n//\t\t\t&#125;\n//\t\t\tSystem.out.println();\n//\t\t&#125;\n//\t&#125;\n\t\n\t//3.2\n//\tpublic int method()&#123;\n//\t\tfor(int i = 0;i &lt; 10;i++)&#123;\n//\t\t\tfor(int j = 0;j &lt; 8;j++)&#123;\n//\t\t\t\tSystem.out.print(\"* \");\n//\t\t\t&#125;\n//\t\t\tSystem.out.println();\n//\t\t&#125;\n//\t\treturn 10 * 8;\n//\t&#125;\n\t\n\t//3.3\n\tpublic int method(int m,int n)&#123;\n\t\tfor(int i = 0;i &lt; m;i++)&#123;\n\t\t\tfor(int j = 0;j &lt; n;j++)&#123;\n\t\t\t\tSystem.out.print(\"* \");\n\t\t\t&#125;\n\t\t\tSystem.out.println();\n\t\t&#125;\n\t\treturn m * n;\n\t&#125;\n&#125;\n\n\n/*\n * 4. 对象数组题目：定义类Student，包含三个属性：\n * 学号number(int)，年级state(int)，成绩score(int)。\n * 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。\n * 问题一：打印出3年级(state值为3）的学生信息。\n * 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息\n * 提示：  1) 生成随机数：Math.random()，返回值类型double;  \n * \t\t2) 四舍五入取整：Math.round(double d)，返回值类型long。\n * \n */\npublic class StudentTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//声明一个Student类型的数组\n\t\tStudent[] stu = new Student[20];\n\t\t\n\t\tfor(int i = 0;i &lt;stu.length;i++)&#123;\n\t\t\t//给数组元素赋值\n\t\t\tstu[i] = new Student();\n\t\t\t//给Student的对象的属性赋值\n\t\t\tstu[i].number = i + 1;\n\t\t\t//年级:[1,6]\n\t\t\tstu[i].state = (int)(Math.random() * (6 - 1 + 1) + 1);\n\t\t\t//成绩:[0,100]\n\t\t\tstu[i].score = (int)(Math.random() * (100 - 0 + 1));\n\t\t&#125;\n\t\t\n\t\t//遍历学生数组\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\n//\t\t\tSystem.out.println(stu[i].number + \",\" + stu[i].state \n//\t\t\t\t+  \",\" + stu[i].score);\n\t\t\t\n\t\t\tSystem.out.println(stu[i].info());\n\t\t&#125;\n\t\tSystem.out.println(\"*********以下是问题1*********\");\n\t\t\n\t\t//问题一：打印出3年级(state值为3）的学生信息。\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\n\t\t\tif(stu[i].state == 3)&#123;\n\t\t\t\tSystem.out.println(stu[i].info());\n\t\t\t&#125;\n\t\t&#125;\n\t\tSystem.out.println(\"********以下是问题2**********\");\n\t\t\n\t\t//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息。\n\t\tfor(int i = 0;i &lt; stu.length - 1;i++)&#123;\n\t\t\tfor(int j = 0;j &lt;stu.length - 1 - i;j++)&#123;\n\t\t\t\tif(stu[j].score >stu[j+1].score)&#123;\n\t\t\t\t\t//如果需要换序，交换的是数组的元素，Student对象！！！\n\t\t\t\t\tStudent temp = stu[j];\n\t\t\t\t\tstu[j] = stu[j+1];\n\t\t\t\t\tstu[j+1] = temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t\n\t\t//遍历学生数组\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\n\t\t\tSystem.out.println(stu[i].info());\n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\nclass Student&#123;\n\tint number;\t//学号\n\tint state;\t//年级\n\tint score;\t//成绩\n\t\n\t//显示学生信息的方法\n\tpublic String info()&#123;\n\t\treturn \"学号:\" + number + \",年级:\" + state + \",成绩:\" + score;\n\t&#125;\n&#125;\n\n\n优化\n/*\n * 4. 对象数组题目：定义类Student，包含三个属性：\n * 学号number(int)，年级state(int)，成绩score(int)。\n * 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。\n * 问题一：打印出3年级(state值为3）的学生信息。\n * 问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息\n * 提示：  1) 生成随机数：Math.random()，返回值类型double;  \n * \t\t2) 四舍五入取整：Math.round(double d)，返回值类型long。\n * \n * 此代码是对StudentTest.java的改进，将操作数组的功能封装到方法中。\n */\npublic class StudentTest2 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//声明一个Student类型的数组\n\t\tStudent2[] stu = new Student2[20];\n\t\t\n\t\tfor(int i = 0;i &lt;stu.length;i++)&#123;\n\t\t\t//给数组元素赋值\n\t\t\tstu[i] = new Student2();\n\t\t\t//给Student的对象的属性赋值\n\t\t\tstu[i].number = i + 1;\n\t\t\t//年级:[1,6]\n\t\t\tstu[i].state = (int)(Math.random() * (6 - 1 + 1) + 1);\n\t\t\t//成绩:[0,100]\n\t\t\tstu[i].score = (int)(Math.random() * (100 - 0 + 1));\n\t\t&#125;\n\t\t\n\t\tStudentTest2 test = new StudentTest2();\n\t\t\n\t\t//遍历学生数组\n\t\ttest.print(stu);\n\t\t\n\t\tSystem.out.println(\"*********以下是问题1*********\");\n\t\t\n\t\t//问题一：打印出3年级(state值为3）的学生信息。\n\t\ttest.searchState(stu, 3);\n\t\tSystem.out.println(\"********以下是问题2**********\");\n\t\t\n\t\t//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息。\n\t\ttest.sort(stu);\n\t\t\n\t\t//遍历学生数组\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\n\t\t\tSystem.out.println(stu[i].info());\n\t\t&#125;\n\t&#125;\n\t\n\t/**\n\t  * \n\t  * @Description 遍历Student[]数组的操作\n\t */\n\tpublic void print(Student2[] stu)&#123;\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\t\n\t\t\tSystem.out.println(stu[i].info());\n\t\t&#125;\n\t&#125;\n\t\n\t/**\n\t  * \n\t  * @Description 查找Student数组中指定年级的学习信息\n\t */\n\tpublic void searchState(Student2[] stu,int state)&#123;\n\t\tfor(int i = 0;i &lt; stu.length;i++)&#123;\n\t\t\tif(stu[i].state == state)&#123;\n\t\t\t\tSystem.out.println(stu[i].info());\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\t\n\t/**\n\t  * \n\t  * @Description 给Student数组排序\n\t */\n\tpublic void sort(Student2[] stu)&#123;\n\t\tfor(int i = 0;i &lt; stu.length - 1;i++)&#123;\n\t\t\tfor(int j = 0;j &lt;stu.length - 1 - i;j++)&#123;\n\t\t\t\tif(stu[j].score >stu[j+1].score)&#123;\n\t\t\t\t\t//如果需要换序，交换的是数组的元素，Student对象！！！\n\t\t\t\t\tStudent2 temp = stu[j];\n\t\t\t\t\tstu[j] = stu[j+1];\n\t\t\t\t\tstu[j+1] = temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nclass Student2&#123;\n\tint number;\t//学号\n\tint state;\t//年级\n\tint score;\t//成绩\n\t\n\t//显示学生信息的方法\n\tpublic String info()&#123;\n\t\treturn \"学号:\" + number + \",年级:\" + state + \",成绩:\" + score;\n\t&#125;\n&#125;\n\n\n万物皆对象/* 1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构。\n * \t\t》Scanner,String等\n * \t\t》文件：File\n * \t\t》网络资源：URL\n * 2.涉及到Java语言与前端html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。\n */\n\n\n\n/*引用类型的变量，只可能存储量两类值：null或地址值（含变量类型）*/\nStudent[] stus= newStudent[5];\nstus[0] = new Student();\nsysout(stus[0].state);//1\nsysout(stus[1]);//null\nsysout(stus[1].number);//异常\nstus[1] = new Student();\nsysout(stus[1].number);//0\n\nclass Student&#123;\n  int number;//学号\n  int state = 1;//年级\n  int score;//成绩\n&#125;\n\n\n1,匿名对象/* \n * 匿名对象的使用\n * 1.理解:我们创建的对象，没有显示的赋值给一个变量名。即为匿名对象。\n * 2.特征：匿名对象只能调用一次。\n * 3.使用:如下\n */\npublic class InstanceTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tPhone p = new Phone();\n//\t\tp = null;\n\t\tSystem.out.println(p);\n\t\t\n\t\tp.sendEmail();\n\t\tp.playGame();\n\t\t\n\t\t//匿名对象\n//\t\tnew Phone().sendEmail();\n//\t\tnew Phone().playGame();\n\t\t\n\t\tnew Phone().price = 1999;\n\t\tnew Phone().showPrice();\t//0.0\n\t\t\n\t\t//*******************************\n\t\tPhoneMall mall = new PhoneMall();\n//\t\tmall.show(p);\n\t\t//匿名对象的使用\n\t\tmall.show(new Phone());\t\n\t&#125;\n&#125;\n\nclass PhoneMall&#123;\n\t\n\tpublic void show(Phone phone)&#123;\n\t\tphone.sendEmail();\n\t\tphone.playGame();\n\t&#125;\n&#125;\n\nclass Phone&#123;\n\tdouble price;\t//价格\n\t\n\tpublic void sendEmail()&#123;\n\t\tSystem.out.println(\"发邮件\");\n\t&#125;\n\tpublic void playGame()&#123;\n\t\tSystem.out.println(\"打游戏\");\n\t&#125;\n\tpublic void showPrice()&#123;\n\t\tSystem.out.println(\"手机价格为:\" + price);\n\t&#125;\n&#125;\n\n\n4,自定义数组的工具类/*\n * 自定义数组工具类\n */\npublic class ArrayUtil &#123;\n\n\t// 求数组的最大值\n\tpublic int getMax(int[] arr) &#123;\n\t\tint maxValue = arr[0];\n\t\tfor (int i = 1; i &lt; arr.length; i++) &#123;\n\t\t\tif (maxValue &lt; arr[i]) &#123;\n\t\t\t\tmaxValue = arr[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn maxValue;\n\t&#125;\n\n\t// 求数组的最小值\n\tpublic int getMin(int[] arr) &#123;\n\t\tint minValue = arr[0];\n\t\tfor (int i = 1; i &lt; arr.length; i++) &#123;\n\t\t\tif (minValue > arr[i]) &#123;\n\t\t\t\tminValue = arr[i];\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn minValue;\n\t&#125;\n\n\t// 求数组总和\n\tpublic int getSum(int[] arr) &#123;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;\n\t\t\tsum += arr[i];\n\t\t&#125;\n\t\treturn sum;\n\t&#125;\n\n\t// 求数组平均值\n\tpublic int getAvg(int[] arr) &#123;\n\t\tint avgValue = getSum(arr) / arr.length;\n\t\treturn avgValue;\n\t&#125;\n\n\t// 反转数组\n\tpublic void reverse(int[] arr) &#123;\n\t\tfor (int i = 0; i &lt; arr.length / 2; i++) &#123;\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[arr.length - i - 1];\n\t\t\tarr[arr.length - i - 1] = temp;\n\t\t&#125;\n\t&#125;\n\n\t// 复制数组\n\tpublic int[] copy(int[] arr) &#123;\n\t\tint[] arr1 = new int[arr.length];\n\t\tfor (int i = 0; i &lt; arr1.length; i++) &#123;\n\t\t\tarr1[i] = arr[i];\n\t\t&#125;\n\t\treturn null;\n\t&#125;\n\n\t// 数组排序\n\tpublic void sort(int[] arr) &#123;\n\t\tfor (int i = 0; i &lt; arr.length - 1; i++) &#123;\n\t\t\tfor (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;\n\t\t\t\tif (arr[j] > arr[j + 1]) &#123;\n\t\t\t\t\tint temp = arr[j];\n\t\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\t\tarr[j + 1] = temp;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t// 遍历数组\n\tpublic void print(int[] arr) &#123;\n\t\tSystem.out.print(\"[\");\n\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;\n\t\t\tSystem.out.print(arr[i] + \",\");\n\t\t&#125;\n\t\tSystem.out.println(\"]\");\n\t&#125;\n\n\t// 查找指定元素\n\tpublic int getIndex(int[] arr, int dest) &#123;\n\t\t//线性查找\n\t\tfor (int i = 0; i &lt; arr.length; i++) &#123;\n\t\t\tif (dest==arr[i]) &#123;\n\t\t\t\treturn i;\n\t\t\t&#125;\n\t\t&#125;\n\t\treturn -1;\n\t&#125;\n&#125;\n/**\n  * @Description 测试类\n  *\n */\npublic class ArrayUtilTest &#123;\n\n\n\tpublic static void main(String[] args) &#123;\n\t\tArrayUtil util = new ArrayUtil();\n\t\tint[] arr = new int[]&#123;32,5,26,74,0,96,14,-98,25&#125;;\n\t\tint max = util.getMax(arr);\n\t\tSystem.out.println(\"最大值为:\" + max);\n\t\t\n//\t\tSystem.out.print(\"排序前:\");\n//\t\tutil.print(arr);\n//\t\t\n//\t\tutil.sort(arr);\n//\t\tSystem.out.print(\"排序后:\");\n//\t\tutil.print(arr);\n\t\t\n\t\tSystem.out.println(\"查找:\");\n\t\tint index = util.getIndex(arr, 5);\n\t\tif(index > 0)&#123;\n\t\t\tSystem.out.println(\"找到了，索引地址:\" + index);\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"没找到\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n5、方法的重载(overload)/*\n * 方法的重载(overload) loading...\n * \n * 1.定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。\n * \t\n * \t\t“两同一不同”:同一个类、相同方法名\n * \t\t\t\t  参数列表不同：参数个数不同，参数类型不同\n * \n * 2.举例:\n * \t\tArrays类中重载的sort() / binarySearch()\n * \n * 3.判断是否重载\n * \t\t与方法的返回值类型、权限修饰符、形参变量名、方法体都无关。\n * \n * 4.在通过对象调用方法时，如何确定某一个指定的方法：\n * \t\t方法名---》参数列表\n */\npublic class OverLoadTest &#123;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\tOverLoadTest test = new OverLoadTest();\n\t\ttest.getSum(1, 2);\t//调用的第一个，输出1\n\t&#125;\n\n\t//如下的四个方法构成了重载\n\tpublic void getSum(int i,int j)&#123;\n\t\tSystem.out.println(\"1\");\n\t&#125;\n\tpublic void getSum(double d1,double d2)&#123;\n\t\tSystem.out.println(\"2\");\n\t&#125;\n\tpublic void getSum(String s,int i)&#123;\n\t\tSystem.out.println(\"3\");\n\t&#125;\n\t\n\tpublic void getSum(int i,String s)&#123;\n\t\t\n\t&#125;\n\t\n\t//以下3个是错误的重载\n//\tpublic int getSum(int i,int j)&#123;\n//\t\treturn 0;\n//\t&#125;\n\t\n//\tpublic void getSum(int m,int n)&#123;\n//\t\t\n//\t&#125;\n\t\n//\tprivate void getSum(int i,int j)&#123;\n//\t\t\n//\t&#125;\n&#125;\n\n\n1.判断：与void show(int a,char b,double c)&#123;&#125;构成重载的有：\n    \na)void show(int x,char y,double z)&#123;&#125; // no\nb)int show(int a,double c,char b)&#123;&#125; // yes\nc) void show(int a,double c,char b)&#123;&#125; // yes\nd) boolean show(int c,char b)&#123;&#125; // yes\ne) void show(double c)&#123;&#125; // yes \nf) double show(int x,char y,double z)&#123;&#125; // no\ng) void shows()&#123;double c&#125; // no\n\n\n/*\n * 1.编写程序，定义三个重载方法并调用。方法名为mOL。\n * 三个方法分别接收一个int参数、两个int参数、一个字符串参数。\n * 分别执行平方运算并输出结果，相乘并输出结果，输出字符串信息。\n * 在主类的main ()方法中分别用参数区别调用三个方法。\n * 2.定义三个重载方法max()，\n * 第一个方法求两个int值中的最大值，\n * 第二个方法求两个double值中的最大值，\n * 第三个方法求三个double值中的最大值，并分别调用三个方法。\n * \n */\npublic class OverLoadever &#123;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\tOverLoadever test = new OverLoadever();\n\t\t//1.调用3个方法\n\t\ttest.mOL(5);\n\t\ttest.mOL(6, 4);\n\t\ttest.mOL(\"fg\");\n\t\t\n\t\t//2.调用3个方法\n\t\tint num1 = test.max(18, 452);\n\t\tSystem.out.println(num1);\n\t\tdouble num2 = test.max(5.6, -78.6);\n\t\tSystem.out.println(num2);\n\t\tdouble num3 = test.max(15, 52, 42);\n\t\tSystem.out.println(num3);\n\t&#125;\n\n\t//1.如下三个方法构成重载\n\tpublic void mOL(int i)&#123;\n\t\tSystem.out.println(i*i);\n\t&#125;\n\tpublic void mOL(int i,int j)&#123;\n\t\tSystem.out.println(i*j);\n\t&#125;\n\tpublic void mOL(String s)&#123;\n\t\tSystem.out.println(s);\n\t&#125;\n\t\n\t//2.如下三个方法构成重载\n\tpublic int max(int i,int j)&#123;\n\t\treturn (i > j) ? i : j;\n\t&#125;\n\tpublic double max(double i,double j)&#123;\n\t\treturn (i > j) ? i : j;\n\t&#125;\n\tpublic double max(double d1,double d2,double d3)&#123;\n\t\tdouble max = (d1 > d2) ? d1 : d2;\n\t\treturn (max > d3) ? max : d3;\n\t&#125;\n&#125;\n\n\n6,可变个数的形参JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。\n/*\n * 可变个数形参的方法\n * 1.jdk 5.0新增的内容\n * 2.具体使用：\n * \t2.1 可变个数形参的格式：数据类型 ... 变量名\n * \t2.2 当调用可变个数形参的方法时，传入的参数的个数可以是：0个，1个，2个...\n * \t2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。\n *  2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。即二者不可共存。\n *  2.5可变个数形参在方法中的形参中,必须声明在末尾。\n *  2.6可变个数形参在方法中的形参中，最多只能声明一个可变形参。\n */\npublic class MethodArgs &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tMethodArgs test = new MethodArgs();\n\t\ttest.show(12);\n\t\t// test.show(\"hell0\");\n\t\t// test.show(\"hello\",\"world\");\n\t\t// test.show();\n\n\t\ttest.show(new String[] &#123; \"AA\", \"BB\", \"CC\" &#125;);\n\t&#125;\n\n\tpublic void show(int i) &#123;\n\n\t&#125;\n\n\t// public void show(String s)&#123;\n\t// System.out.println(\"show(String)\");\n\t// &#125;\n\tpublic void show(String... strs) &#123;\n\t\tSystem.out.println(\"show(String ...strs)\");\n\n\n\t\tfor (int i = 0; i &lt; strs.length; i++) &#123;\n\t\t\tSystem.out.println(strs[i]);\n\t\t&#125;\n\t&#125;\n\n\t// 此方法与上一方法不可共存\n\t// public void show(String[] strs)&#123;\n\t//\n\t// &#125;\n\n\tpublic void show(int i, String... strs) &#123;\n\n\t&#125;\n\n\t//The variable argument type String of the method show must be the last parameter\n//\tpublic void show(String... strs,int i,) &#123;\n//\n//\t&#125;\n&#125;\n\n\n7,方法参数的值传递机制/*\n * 关于变量的赋值\n * \n * \t如果变量是基本数据类型，此时赋值的是变量所保存的数据值。\n * \t如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。\n * \n */\npublic class ValueTransferTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tSystem.out.println(\"**********基本数据类型：***********\");\n\t\tint m = 10;\n\t\tint n = m;\n\t\t\n\t\tSystem.out.println(\"m = \" + m + \", n = \" + n);\n\t\t\n\t\tn = 20;\n\t\t\n\t\tSystem.out.println(\"m = \" + m + \", n = \" + n);\n\n\t\tSystem.out.println(\"***********引用数据类型:********\");\n\t\t\n\t\tOrder o1 = new Order();\n\t\to1.orderId = 1001;\n\t\t\n\t\tOrder o2 = o1;\t//赋值后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体\n\t\tSystem.out.println(\"o1.orderId = \" + o1.orderId + \",o2.orderId = \" + o2.orderId);\n\t\t\n\t\to2.orderId = 1002;\n\t\tSystem.out.println(\"o1.orderId = \" + o1.orderId + \",o2.orderId = \" + o2.orderId);\n\t\t\n\t&#125;\n&#125;\n\nclass Order&#123;\n\tint orderId;\n&#125;\n\n\n8,基本数据类型/*\n * 方法的形参的传递机制：值传递\n * \n * 1.形参：方法定义时，声明的小括号内的参数\n *   实参：方法调用时，实际传递给形参的数据\n * \n * 2.值传递机制：\n *  如果参数是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值。\n */\npublic class ValueTransferTest1 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tint m = 10;\n\t\tint n = 20;\n\t\t\n\t\tSystem.out.println(\"m = \" + m + \", n = \" + n);\n\t\t//交换两个变量的值的操作\n//\t\tint temp = m;\n//\t\tm = n;\n//\t\tn = temp;\n\t\t\n\t\tValueTransferTest1 test = new ValueTransferTest1();\n\t\ttest.swap(m, n);\n\t\t\n\t\tSystem.out.println(\"m = \" + m + \", n = \" + n);\n\t\t\n\t&#125;\n\t\n\tpublic void swap(int m,int n)&#123;\n\t\tint temp = m;\n\t\tm = n;\n\t\tn = temp;\n\t&#125;\n&#125;\n\n\n9,引用数据类型\n/*\n *  如果参数是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值。\n */\npublic class ValueTransferTest2 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tData data = new Data();\n\t\t\n\t\tdata.m = 10;\n\t\tdata.n = 20;\n\t\t\n\t\tSystem.out.println(\"m = \" + data.m + \", n = \" + data.n);\n\n\t\t//交换m和n的值\n//\t\tint temp = data.m;\n//\t\tdata.m = data.n;\n//\t\tdata.n = temp;\n\n\t\tValueTransferTest2 test = new ValueTransferTest2();\n\t\ttest.swap(data);\n\t\t\n\t\tSystem.out.println(\"m = \" + data.m + \", n = \" + data.n);\n\n\t&#125;\n\t\n\tpublic void swap(Data data)&#123;\n\t\tint temp = data.m;\n\t\tdata.m = data.n;\n\t\tdata.n = temp;\n\t&#125;\n&#125;\n\n\nclass Data&#123;\n\t\n\tint m;\n\tint n;\n&#125;\n\n\n\npublic class TransferTest3&#123;\n\tpublic static void main(String args[])&#123;\n\t\tTransferTest3 test=new TransferTest3();\n\t\ttest.first();\n\t&#125;\n\t\n\tpublic void first()&#123;\n\t\tint i=5;\n\t\tValue v=new Value();\n\t\tv.i=25;\n\t\tsecond(v,i);\n\t\tSystem.out.println(v.i);\n\t&#125;\n\t\n\tpublic void second(Value v,int i)&#123;\n\t\ti=0;\n\t\tv.i=20;\n\t\tValue val=new Value();\n\t\tv=val;\n\t\tSystem.out.println(v.i+\" \"+i);\n\t\t\n\t&#125;\n&#125;\nclass Value &#123;\n\tint i= 15;\n&#125; \n\n\n\npublic static void method(int a,int b)&#123;\n\ta = a * 10;\n\tb = b * 20;\n\tSystem.out.println(a);\n\tSystem.out.println(b);\n\tSystem.exit(0);\n&#125;\n\n\n\n/*\n * 微软：\n * 定义一个int型的数组：int[] arr = new int[]&#123;12,3,3,34,56,77,432&#125;;\n * 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的新值。遍历新的数组。 \n */\n \n//错误写法\nfor(int i= 0;i &lt; arr.length;i++)&#123;\n\tarr[i] = arr[i] / arr[0];\n&#125;\n\n//正确写法1\nfor(int i = arr.length –1;i >= 0;i--)&#123;\n\tarr[i] = arr[i] / arr[0];\n&#125;\n\n//正确写法2\nint temp = arr[0];\nfor(int i= 0;i &lt; arr.length;i++)&#123;\n\tarr[i] = arr[i] / temp;\n&#125;\n\n\n/*\n * int[] arr = new int[10];\n * System.out.println(arr);//地址值?\n * \n * char[] arr1 = new char[10];\n * System.out.println(arr1);//地址值?\n */\npublic class ArrayPrint &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tint[] arr = new int[]&#123;1,2,3&#125;;\n        //传进去的是一个Object的对象\n\t\tSystem.out.println(arr);//地址值\n\t\t\n\t\tchar[] arr1 = new char[]&#123;'a','b','c'&#125;;\n        //传进去的是一个数组，里面遍历数据了\n\t\tSystem.out.println(arr1);//abc\n\t&#125;\n&#125;\n\n\n对象作为参数传递给方法/*\n * 练习5：将对象作为参数传递给方法\n * (1)定义一个Circle类，包含一个double型的radius属性代表圆的半径，一个findArea()方法返回圆的面积。\n * \n * (2)定义一个类PassObject，在类中定义一个方法printAreas()，该方法的定义如下：\n * public void printAreas(Circle c,int time)\n * 在printAreas方法中打印输出1到time之间的每个整数半径值，以及对应的面积。\n * 例如，times为5，则输出半径1，2，3，4，5，以及对应的圆面积。\n * \n * (3)在main方法中调用printAreas()方法，调用完毕后输出当前半径值。\n *\n */\npublic class Circle &#123;\n\n\tdouble radius;\t//半径\n\t\n\t//返回圆的面积\n\tpublic double findArea()&#123;\n\t\treturn radius * radius * Math.PI;\n\t&#125;\n&#125;\npublic class PassObject &#123;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\tPassObject test = new PassObject();\n\t\t\n\t\tCircle c = new Circle();\n\t\t\n\t\ttest.printAreas(c, 5);\n\t\t\n\t\tSystem.out.println(\"no radius is:\" + c.radius);\n\t&#125;\n\t\n\tpublic void printAreas(Circle c,int time)&#123;\n\t\t\n\t\tSystem.out.println(\"Radius\\t\\tAreas\");\n\t\t\n\t\t//设置圆的半径\n\t\tfor(int i = 1;i &lt;= time ;i++)&#123;\n\t\t\tc.radius = i;\n\t\t\tSystem.out.println(c.radius + \"\\t\\t\" + c.findArea());\n\t\t&#125;\n\t\t\n\t\t//重新赋值\n\t\tc.radius = time + 1;\n\t&#125;\n&#125;\n\n\n递归/*\n * 递归方法的使用(了解)\n * 1.递归方法：一个方法体内调用它自身。\n * 2.方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。\n * \n * 3.递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。\n * \n */\npublic class RecursionTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\n\t\t// 例1:计算1-100之间所有自然数的和\n\t\t// 方法1:\n\t\tint sum = 0;\n\t\tfor (int i = 1; i &lt;= 100; i++) &#123;\n\t\t\tsum += i;\n\t\t&#125;\n\t\tSystem.out.println(\"sum = \" + sum);\n\n\t\t// 方法2:\n\t\tRecursionTest test = new RecursionTest();\n\t\tint sum1 = test.getSum(100);\n\t\tSystem.out.println(\"sum1 = \" + sum1);\n\t&#125;\n\n\t// 例1:计算1-n之间所有自然数的和\n\tpublic int getSum(int n) &#123;\n\n\t\tif (n == 1) &#123;\n\t\t\treturn 1;\n\t\t&#125; else &#123;\n\t\t\treturn n + getSum(n - 1);\n\t\t&#125;\n\t&#125;\n\n\t// 例2:计算1-n之间所有自然数的乘积\n\t//归求阶乘(n!)的算法\n\tpublic int getSum1(int n) &#123;\n\n\n\t\tif (n == 1) &#123;\n\t\t\treturn 1;\n\t\t&#125; else &#123;\n\t\t\treturn n * getSum1(n - 1);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\npublic class RecursionTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\n\t\tint value = test.f(10);\n\t\tSystem.out.println(value);\n\t&#125;\n\n\t//例3:已知有一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),\n\t//其中n是大于0的整数，求f(10)的值。\n\tpublic int f(int n)&#123;\n\t\tif(n == 0)&#123;\n\t\t\treturn 1;\n\t\t&#125;else if(n == 1)&#123;\n\t\t\treturn 4;\n\t\t&#125;else&#123;\n\t\t\treturn 2*f(n-1) + f(n-2);\n\t\t&#125;\n\t&#125;\n\t\n\t//例4:已知一个数列：f(20) = 1,f(21) = 4,f(n+2) = 2*f(n+1)+f(n),\n\t//其中n是大于0的整数，求f(10)的值。\n\tpublic int f1(int n)&#123;\n\t\tif(n == 20)&#123;\n\t\t\treturn 1;\n\t\t&#125;else if(n == 21)&#123;\n\t\t\treturn 4;\n\t\t&#125;else&#123;\n\t\t\treturn 2*f1(n-1) + f1(n-2);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n/*\n * 输入一个数据n，计算斐波那契数列(Fibonacci)的第n个值\n * 1  1  2  3  5  8  13  21  34  55\n * 规律：一个数等于前两个数之和\n * 要求：计算斐波那契数列(Fibonacci)的第n个值，并将整个数列打印出来\n * \n */\npublic class Recursion2 &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tRecursion2 test = new Recursion2();\n\t\tint value = test.f(10);\n\t\tSystem.out.println(value);\n\t&#125;\n\t\n\tpublic int f(int n) &#123;\n\n\t\tif (n == 1 || n == 2) &#123;\n\t\t\treturn 1;\n\t\t&#125; else &#123;\n\t\t\treturn f(n - 1) + f(n - 2);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n3,特征；封闭与隐藏为什么需要封装？封装的作用和含义？我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？我要开车，…\n2、我们程序设计追求“高内聚，低耦合”。\n高内聚：类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅对外暴露少量的方法用于使用。\n3、隐藏对象内部的复杂性，只对外公开简单的接口。\n便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。\n/*\n * 面向对象的特征一:封装与隐藏\n * 一、问题的引入：\n *    当我们创建一个类的对象以后，我们可以通过\"对象.属性\"的方式，对对象的属性进行赋值。这里，赋值操作要受到\n *    属性的数据类型和存储范围的制约。但除此之外，没有其他制约条件。但是，实际问题中，我们往往需要给属性赋值\n *    加入额外限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行条件的添加。比如说，setLegs\n *    同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)\n *    --》此时，针对于属性就体现了封装性。\n *    \n * 二、封装性的体现：\n *    我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)\n *    \n *    拓展：封装性的体现：① 如上 ② 单例模式 ③ 不对外暴露的私有方法\n *\n */\npublic class AnimalTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tAnimal a = new Animal();\n\t\ta.name = \"大黄\";\n//\t\ta.age = 1;\n//\t\ta.legs = 4;//The field Animal.legs is not visible\n\t\t\n\t\ta.show();\n\t\t\n//\t\ta.legs = -4;\n//\t\ta.setLegs(6);\n\t\ta.setLegs(-6);\n\t\t\n//\t\ta.legs = -4;//The field Animal.legs is not visible\n\t\ta.show();\n\t\t\n\t\tSystem.out.println(a.name);\n\t\tSystem.out.println(a.getLegs());\n\t&#125;\n&#125;\nclass Animal&#123;\n\t\n\tString name;\n\tprivate int age;\n\tprivate int legs; //腿的个数\n\t\n\t//对于属性的设置\n\tpublic void setLegs(int l)&#123;\n\t\tif(l >= 0 &amp;&amp; l % 2 == 0)&#123;\n\t\t\tlegs = l;\n\t\t&#125;else&#123;\n\t\t\tlegs = 0;\n\t\t&#125;\n\t&#125;\n\t\n\t//对于属性的获取\n\tpublic int getLegs()&#123;\n\t\treturn legs;\n\t&#125;\n\t\n\tpublic void eat()&#123;\n\t\tSystem.out.println(\"动物进食\");\n\t&#125;\n\t\n\tpublic void show()&#123;\n\t\tSystem.out.println(\"name = \" + name + \",age = \" + age + \",legs = \" + legs);\n\t&#125;\n\t\n\t//提供关于属性 age 的 get 和 set 方法\n\tpublic int getAge()&#123;\n\t\treturn age;\n\t&#125;\n\t\n\tpublic void setAge(int a)&#123;\n\t\tage = a;\n\t&#125;\n&#125;\n\n\n\n\nJava 权限修饰符public、protected、default(缺省)、private 置于类的成员定义前，用来限定对象对该类成员的访问权限。\n\n对于 class 的权限修饰只可以用 public 和 default(缺省)。\n\npublic 类可以在任意地方被访问。\ndefault 类只可以被同一个包内部的类访问。\n\n/*\n * 三、封装性的体现，需要权限修饰符来配合。\n *   1.Java 规定的 4 种权限：(从小到大排序)private、缺省、protected、public\n *   2.4 种权限用来修饰类及类的内部结构：属性、方法、构造器、内部类\n *   3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类\n * \t\t 修饰类的话，只能使用：缺省、public\n *  总结封装性：Java 提供了 4 中权限修饰符来修饰类积累的内部结构，体现类及类的内部结构的可见性的方法。\n * \n */\npublic class Order &#123;\n\n\tprivate int orderPrivate;\n\tint orderDefault;\n\tpublic int orderPublic;\n\t\n\tprivate void methodPrivate()&#123;\n\t\torderPrivate = 1;\n\t\torderDefault = 2;\n\t\torderPublic = 3;\n\t&#125;\n\t\n\tvoid methodDefault()&#123;\n\t\torderPrivate = 1;\n\t\torderDefault = 2;\n\t\torderPublic = 3;\n\t&#125;\n\t\n\tpublic void methodPublic()&#123;\n\t\torderPrivate = 1;\n\t\torderDefault = 2;\n\t\torderPublic = 3;\n\t&#125;\n&#125;\npublic class OrderTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tOrder order = new Order();\n\t\t\n\t\torder.orderDefault = 1;\n\t\torder.orderPublic = 2;\n\t\t//出了 Order 类之后，私有的结构就不可调用了\n//\t\torder.orderPrivate = 3;//The field Order.orderPrivate is not visible\n\t\t\n\t\torder.methodDefault();\n\t\torder.methodPublic();\n\t\t//出了 Order 类之后，私有的结构就不可调用了\n//\t\torder.methodPrivate();//The method methodPrivate() from the type Order is not visible\n\t&#125;\n&#125;\n\n\n相同项目不同包的 OrderTest 类\nimport github.Order;\n\npublic class OrderTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tOrder order = new Order();\n\t\t\n\t\torder.orderPublic = 2;\n\t\t//出了 Order 类之后，私有的结构、缺省的声明结构就不可调用了\n//\t\torder.orderDefault = 1;\n//\t\torder.orderPrivate = 3;//The field Order.orderPrivate is not visible\n\t\t\n\t\torder.methodPublic();\n\t\t//出了 Order 类之后，私有的结构、缺省的声明结构就不可调用了\n//\t\torder.methodDefault();\n//\t\torder.methodPrivate();//The method methodPrivate() from the type Order is not visible\n\t&#125;\n&#125;\n\n\n\n/*\n * 1.创建程序,在其中定义两个类：Person 和 PersonTest 类。\n * 定义如下：用 setAge()设置人的合法年龄(0~130)，用 getAge()返回人的年龄。\n * \n */\npublic class Person &#123;\n\n\tprivate int age;\n\t\n\tpublic void setAge(int a)&#123;\n\t\tif(a &lt; 0 || a > 130)&#123;\n//\t\t\tthrow new RuntimeException(\"传入的数据据非法\");\n\t\t\tSystem.out.println(\"传入的数据据非法\");\n\t\t\treturn;\n\t\t&#125;\n\t\t\n\t\tage = a;\n\t\t\n\t&#125;\n\t\n\tpublic int getAge()&#123;\n\t\treturn age;\n\t&#125;\n\t\n\t//绝对不能这样写！！！\n\tpublic int doAge(int a)&#123;\n\t\tage = a;\n\t\treturn age;\n\t&#125;\n&#125;\n\n/*\n *  在 PersonTest 类中实例化 Person 类的对象 b，\n *  调用 setAge()和 getAge()方法，体会 Java 的封装性。\n */\npublic class PersonTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tPerson p1 = new Person();\n//\t\tp1.age = 1;\t//编译不通过\n\t\t\n\t\tp1.setAge(12);\n\t\t\n\t\tSystem.out.println(\"年龄为:\" + p1.getAge());\n\t&#125;\n&#125;\n\n\n4,构造器(构造方法)/*\n * 类的结构之三:构造器(构造方法、constructor)的使用\n * constructor:\n * \n * 一、构造器的作用:\n * 1.创建对象\n * 2.初始化对象的属性\n * \n * 二、说明\n * 1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器。\n * 2.定义构造器的格式:\n * \t\t\t权限修饰符  类名(形参列表) &#123; &#125;\n * 3.一个类中定义的多个构造器，彼此构成重载。\n * 4.一旦显示的定义了类的构造器之后，系统不再提供默认的空参构造器。\n * 5.一个类中，至少会有一个构造器\t\t\n */\npublic class PersonTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t//创建类的对象:new + 构造器\n\t\tPerson p = new Person();\t//Person()这就是构造器\n\t\t\n\t\tp.eat();\n\t\t\n\t\tPerson p1 = new Person(\"Tom\");\n\t\tSystem.out.println(p1.name);\n\t&#125;\n&#125;\nclass Person&#123;\n\t//属性\n\tString name;\n\tint age;\n\t\n\t//构造器\n\tpublic Person()&#123;\n\t\tSystem.out.println(\"Person()......\");\n\t&#125;\n\t\n\tpublic Person(String n)&#123;\n\t\tname = n;\n\t&#125;\n\t\n\tpublic Person(String n,int a)&#123;\n\t\tname = n;\n\t\tage = a;\n\t&#125;\n\t\n\t//方法\n\tpublic void eat()&#123;\n\t\tSystem.out.println(\"人吃饭\");\n\t&#125;\n\t\n\tpublic void study()&#123;\n\t\tSystem.out.println(\"人学习\");\n\t&#125;\n&#125;\n\n\n/* 2.在前面定义的 Person 类中添加构造器，\n * 利用构造器设置所有人的 age 属性初始值都为 18。\n * \n */\npublic class Person &#123;\n\n\tprivate int age;\n\t\n\tpublic Person()&#123;\n\t\tage = 18;\n\t&#125;\n&#125;\n\npublic class PersonTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tPerson p1 = new Person();\n\n\t\tSystem.out.println(\"年龄为:\" + p1.getAge());\n\t&#125;\n&#125;\n\n\n/*\n * 编写两个类，TriAngle 和 TriAngleTest，\n * 其中 TriAngle 类中声明私有的底边长 base 和高 height，同时声明公共方法访问私有变量。\n * 此外，提供类必要的构造器。另一个类中使用这些公共方法，计算三角形的面积。\n * \n */\npublic class TriAngle &#123;\n\n\tprivate double base;//底边长\n\tprivate double height;//高\n\t\n\tpublic TriAngle()&#123;\n\t\t\n\t&#125;\n\t\n\tpublic TriAngle(double b,double h)&#123;\n\t\tbase = b;\n\t\theight = h;\n\t&#125;\n\t\n\tpublic void setBase(double b)&#123;\n\t\tbase = b;\n\t&#125;\n\t\n\tpublic double getBase()&#123;\n\t\treturn base;\n\t&#125;\n\t\n\tpublic void setHeight(double h)&#123;\n\t\theight = h;\n\t&#125;\n\t\n\tpublic double getHeight()&#123;\n\t\treturn height;\n\t&#125;\n&#125;\n\npublic class TriAngleTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tTriAngle t1 = new TriAngle();\n\t\tt1.setBase(2.0);\n\t\tt1.setHeight(2.5);\n//\t\tt1.base = 2.5;//The field TriAngle.base is not visible\n//\t\tt1.height = 4.3;\t\t\n\t\tSystem.out.println(\"base : \" + t1.getBase() + \",height : \" + t1.getHeight());\n\t\t\n\t\tTriAngle t2 = new TriAngle(5.1,5.6);\n\t\tSystem.out.println(\"面积 : \" + t2.getBase() * t2.getHeight() / 2);\n\n\t&#125;\n&#125;\n\n\n/*\n * 总结:属性赋值的先后顺序\n * \n * ① 默认初始化值\n * ② 显式初始化\n * ③ 构造器中赋值\n * ④ 通过\"对象.方法\" 或 “对象.属性”的方式，赋值\n * \n * 以上操作的先后顺序:① - ② - ③ - ④\n * \n */\npublic class UserTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tUser u = new User();\n\t\t\n\t\tSystem.out.println(u.age);\n\t\t\n\t\tUser u1 = new User(2);\n\t\t\n\t\tu1.setAge(3);\n\t\t\n\t\tSystem.out.println(u1.age);\n\t&#125;\n&#125;\nclass User&#123;\n\tString name;\n\tint age = 1;\n\t\n\tpublic User()&#123;\n\t\t\n\t&#125;\n\t\n\tpublic User(int a)&#123;\n\t\tage = a;\n\t&#125;\n\t\n\tpublic void setAge(int a)&#123;\n\t\tage = a;\n\t&#125;\n&#125;\n\n\njavaBean的使用/*\n * JavaBean 是一种 Java 语言写成的可重用组件。\n * 所谓 javaBean，是指符合如下标准的 Java 类：\n * \t\t> 类是公共的\n * \t\t> 有一个无参的公共的构造器\n * \t\t> 有属性，且有对应的 get、set 方法\n * \n */\npublic class Customer &#123;\n\t\n\tprivate int id;\n\tprivate String name;\n\n\tpublic Customer()&#123;\n\t\t\n\t&#125;\n\t\n\tpublic void setId(int i)&#123;\n\t\tid = i;\n\t&#125;\n\t\n\tpublic int getId()&#123;\n\t\treturn id;\n\t&#125;\n\t\n\tpublic void setName(String n)&#123;\n\t\tname = n;\n\t&#125;\n\t\n\tpublic String getName()&#123;\n\t\treturn name;\n\t&#125;\n&#125;\n\n\nUML 类图\n\n表示 public 类型，-表示 private 类型，#表示 protected 类型\n方法的写法: 方法的类型(+、-) 方法名(参数名：参数类型)：返回值类型\n\n5,this/*\n * this 关键字的使用\n * 1.this 用来修饰、调用：属性、方法、构造器\n * \n * 2.this 修饰属性和方法:\n * \t\tthis 理解为：当前对象,或当前正在创建的对象。\n * \t \n *  2.1 在类的方法中，我们可以使用\"this.属性\"或\"this.方法\"的方式，调用当前对象属性和方法。\n *  \t通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名，我们必须显式\n *  \t的使用\"this.变量\"的方式，表明此变量是属性，而非形参。\n * \n *  2.2 在类的构造器中，我们可以使用\"this.属性\"或\"this.方法\"的方式，调用正在创建的对象属性和方法。\n *  \t但是，通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名，我们必须显式\n *  \t的使用\"this.变量\"的方式，表明此变量是属性，而非形参。\n *  \n *  3.this 调用构造器\n *  \t① 我们可以在类的构造器中，显式的使用\"this(形参列表)\"的方式，调用本类中重载的其他的构造器！\n *  \t② 构造器中不能通过\"this(形参列表)\"的方式调用自己。\n *  \t③ 如果一个类中声明了n个构造器，则最多有n -1个构造器中使用了\"this(形参列表)\"。\n *  \t④ \"this(形参列表)\"必须声明在类的构造器的首行！\n *  \t⑤ 在类的一个构造器中，最多只能声明一个\"this(形参列表)\"。\n */\npublic class PersonTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tPerson p1 = new Person();\n\t\t\n\t\tp1.setAge(1);\n\t\tSystem.out.println(p1.getAge());\n\t\t\n\t\tp1.eat();\n\t\tSystem.out.println();\n\t\t\n\t\tPerson p2 = new Person(\"jerry\" ,20);\n\t\tSystem.out.println(p2.getAge());\n\t&#125;\n&#125;\nclass Person&#123;\n\t\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic Person()&#123;\n\t\tthis.eat();\n\t\tString info = \"Person 初始化时，需要考虑如下的 1,2,3,4...(共 40 行代码)\";\n\t\tSystem.out.println(info);\n\t&#125;\n\t\n\tpublic Person(String name)&#123;\n\t\tthis();\n\t\tthis.name = name;\n\t&#125;\n\t\n\tpublic Person(int age)&#123;\n\t\tthis();\n\t\tthis.age = age;\n\t&#125;\n\t\n\tpublic Person(String name,int age)&#123;\n\t\tthis(age);\t//调用构造器的一种方式\n\t\tthis.name = name;\n//\t\tthis.age = age;\n\t&#125;\n\t\n\tpublic void setNmea(String name)&#123;\n\t\tthis.name = name;\n\t&#125;\n\t\n\tpublic String getName()&#123;\n\t\treturn this.name;\n\t&#125;\n\t\n\tpublic void setAge(int age)&#123;\n\t\tthis.age = age;\n\t&#125;\n\t\n\tpublic int getAge()&#123;\n\t\treturn this.age;\n\t&#125;\n\t\n\tpublic void eat()&#123;\n\t\tSystem.out.println(\"人吃饭\");\n\t\tthis.study();\n\t&#125;\n\t\n\tpublic void study()&#123;\n\t\tSystem.out.println(\"学习\");\n\t&#125;\n&#125;\n\n\n\npublic class Boy &#123;\n\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic void setName(String name)&#123;\n\t\tthis.name = name;\n\t&#125;\n\t\n\tpublic String getName()&#123;\n\t\treturn name;\n\t&#125;\n\t\n\tpublic void setAge(int ahe)&#123;\n\t\tthis.age = age;\n\t&#125;\n\t\n\tpublic int getAge()&#123;\n\t\treturn age;\n\t&#125;\n\t\n\tpublic Boy(String name, int age) &#123;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t&#125;\n\n\n\tpublic void marry(Girl girl)&#123;\n\t\tSystem.out.println(\"我想娶\" + girl.getName());\n\t&#125;\n\t\n\tpublic void shout()&#123;\n\t\tif(this.age >= 22)&#123;\n\t\t\tSystem.out.println(\"可以考虑结婚\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"好好学习\");\n\t\t&#125;\n\t&#125;\n&#125;\npublic class Girl &#123;\n\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t\n\tpublic Girl()&#123;\n\t\t\n\t&#125;\n\tpublic Girl(String name, int age) &#123;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t&#125;\n\t\n\tpublic void marry(Boy boy)&#123;\n\t\tSystem.out.println(\"我想嫁给\" + boy.getName());\n\t&#125;\n\t/**\n\t  * \n\t  * @Description 比较两个对象的大小\n\t  * @author subei\n\t  * @date 2020 年 4 月 21 日上午 9:17:35\n\t  * @param girl\n\t  * @return\n\t */\n\tpublic int compare(Girl girl)&#123;\n//\t\tif(this.age >girl.age)&#123;\n//\t\t\treturn 1;\n//\t\t&#125;else if(this.age &lt; girl.age)&#123;\n//\t\t\treturn -1;\n//\t\t&#125;else&#123;\n//\t\t\treturn 0;\n//\t\t&#125;\n\t\t\n\t\treturn this.age - girl.age;\n\t&#125;\n\t\n&#125;\npublic class BoyGirlTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tBoy boy = new Boy(\"罗密欧\",21);\n\t\tboy.shout();\n\t\t\n\t\tGirl girl = new Girl(\"朱丽叶\", 18);\n\t\tgirl.marry(boy);\n\t\t\n\t\tGirl girl1 = new Girl(\"祝英台\", 19);\n\t\tint compare = girl.compare(girl1);\n\t\tif(compare > 0)&#123;\n\t\t\tSystem.out.println(girl.getName() + \"大\");\n\t\t&#125;else if(compare &lt; 0)&#123;\n\t\t\tSystem.out.println(girl1.getName() + \"大\");\n\t\t&#125;else&#123;\n\t\t\tSystem.out.println(\"一样的\");\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\npublic class Account &#123;\n\n\tprivate int id; // 账号\n\tprivate double balance; // 余额\n\tprivate double annualInterestRate; // 年利率\n\n\tpublic void setId(int id) &#123;\n\n\t&#125;\n\n\tpublic double getBalance() &#123;\n\t\treturn balance;\n\t&#125;\n\n\tpublic void setBalance(double balance) &#123;\n\t\tthis.balance = balance;\n\t&#125;\n\n\tpublic double getAnnualInterestRate() &#123;\n\t\treturn annualInterestRate;\n\t&#125;\n\n\tpublic void setAnnualInterestRate(double annualInterestRate) &#123;\n\t\tthis.annualInterestRate = annualInterestRate;\n\t&#125;\n\n\tpublic int getId() &#123;\n\t\treturn id;\n\t&#125;\n\n\tpublic void withdraw(double amount) &#123; // 取钱\n\t\tif(balance &lt; amount)&#123;\n\t\t\tSystem.out.println(\"余额不足，取款失败\");\n\t\t\treturn;\n\t\t&#125;\n\t\tbalance -= amount;\n\t\tSystem.out.println(\"成功取出\" + amount);\n\t&#125;\n\n\tpublic void deposit(double amount) &#123; // 存钱\n\t\tif(amount > 0)&#123;\n\t\t\tbalance += amount;\n\t\t\tSystem.out.println(\"成功存入\" + amount);\n\t\t&#125;\n\t&#125;\n\n\tpublic Account(int id, double balance, double annualInterestRate) &#123;\n\t\tthis.id = id;\n\t\tthis.balance = balance;\n\t\tthis.annualInterestRate = annualInterestRate;\n\t&#125;\n\t\n\t\n&#125;\npublic class Customer &#123;\n\n\tprivate String firstName;\n\tprivate String lastName;\n\tprivate Account account;\n\n\tpublic Customer(String f, String l) &#123;\n\t\tthis.firstName = f;\n\t\tthis.lastName = l;\n\t&#125;\n\n\tpublic String getFirstName() &#123;\n\t\treturn firstName;\n\t&#125;\n\n\tpublic String getLastName() &#123;\n\t\treturn lastName;\n\t&#125;\n\n\tpublic Account getAccount() &#123;\n\t\treturn account;\n\t&#125;\n\n\tpublic void setAccount(Account account) &#123;\n\t\tthis.account = account;\n\t&#125;\n\t\n&#125;\n/*\n * 写一个测试程序。\n * （1）创建一个 Customer，名字叫 Jane Smith, 他有一个账号为 1000，\n * 余额为 2000 元，年利率为 1.23％的账户。\n * （2）对 Jane Smith 操作。存入 100 元，再取出 960 元。再取出 2000 元。\n * 打印出 Jane Smith 的基本信息\n * \n * 成功存入：100.0\n * 成功取出：960.0\n * 余额不足，取款失败\n * Customer  [Smith,  Jane]  has  a  account:  id  is 1000, \n *  annualInterestRate  is 1.23％,  balance  is 1140.0\n *  \n */\npublic class CustomerTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tCustomer cust = new Customer(\"Jane\" , \"Smith\");\n\t\t\n\t\tAccount acct = new Account(1000,2000,0.0123);\n\t\t\n\t\tcust.setAccount(acct);\n\t\t\n\t\tcust.getAccount().deposit(100); //存入 100\n\t\tcust.getAccount().withdraw(960); //取钱 960\n\t\tcust.getAccount().withdraw(2000); //取钱 2000\n\t\t\n\t\tSystem.out.println(\"Customer[\" + cust.getLastName() + cust.getFirstName() + \"]  has  a  account:  id  is \"\n\t\t\t\t+ cust.getAccount().getId() + \",annualInterestRate  is \" + cust.getAccount().getAnnualInterestRate() * 100 + \"%,  balance  is \"\n\t\t\t\t+ cust.getAccount().getBalance());\n\t&#125;\n&#125;\n\n\npublic class Customer &#123;\n\n\tprivate String firstName;\n\tprivate String lastName;\n\tprivate Account account;\n\t\n\tpublic String getFirstName() &#123;\n\t\treturn firstName;\n\t&#125;\n\tpublic String getLastName() &#123;\n\t\treturn lastName;\n\t&#125;\n\tpublic Account getAccount() &#123;\n\t\treturn account;\n\t&#125;\n\tpublic void setAccount(Account account) &#123;\n\t\tthis.account = account;\n\t&#125;\n\tpublic Customer(String f, String l) &#123;\n\t\tthis.firstName = f;\n\t\tthis.lastName = l;\n\t&#125;\t\n&#125;\npublic class Bank &#123;\n\n\tprivate int numberOfCustomers;\t//记录客户的个数\n\tprivate Customer[] customers;\t//存放多个客户的数组\n\t\n\tpublic Bank()&#123;\n\t\tcustomers = new Customer[10];\n\t&#125;\n\t\n\t//添加客户\n\tpublic void addCustomer(String f,String l)&#123;\n\t\tCustomer cust = new Customer(f,l);\n//\t\tcustomers[numberOfCustomers] = cust;\n//\t\tnumberOfCustomers++;\n\t\tcustomers[numberOfCustomers++] = cust;\n\t&#125;\n\n\t//获取客户的个数\n\tpublic int getNumberOfCustomers() &#123;\n\t\treturn numberOfCustomers;\n\t&#125;\n\n\t//获取指定位置上的客户\n\tpublic Customer getCustomers(int index) &#123;\n//\t\treturn customers;\t//可能报异常\n\t\tif(index >= 0 &amp;&amp; index &lt; numberOfCustomers)&#123;\n\t\t\treturn customers[index];\n\t\t&#125;\n\t\t\n\t\treturn null;\n\t&#125;\t\n\t\n&#125;\npublic class BankTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t\n\t\tBank bank = new Bank();\n\t\t\n\t\tbank.addCustomer(\"Jane\", \"Smith\");\t\n\t\t\n\t\tbank.getCustomers(0).setAccount(new Account(2000));\n\t\t\n\t\tbank.getCustomers(0).getAccount().withdraw(500);\n\t\t\n\t\tdouble balance = bank.getCustomers(0).getAccount().getBalance();\n\t\t\n\t\tSystem.out.println(\"客户: \" + bank.getCustomers(0).getFirstName() + \"的账户余额为：\" + balance);\n\t\t\n\t\tSystem.out.println(\"***************************\");\n\t\tbank.addCustomer(\"万里\", \"杨\");\n\t\t\n\t\tSystem.out.println(\"银行客户的个数为: \" + bank.getNumberOfCustomers());\n\t\t\n\t&#125;\n&#125;\n\n\n6,关键字/*\n * 一、package 关键字的使用\n * 1.为了更好的实现项目中类的管理，提供包的概念\n * 2.使用 package 声明类或接口所属的包，声明在源文件的首行\n * 3.包，属于标识符，遵循标识符的命名规则、规范\"见名知意\"\n * 4.每“.”一次,就代表一层文件目录。\n * \n * 补充:同一个包下，不能命名同名接口或同名类\n *     不同包下，可以命名同名的接口、类。\n *\n */\npublic class PackageImportTest &#123;\n\n&#125;\n1.java.lang----包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能\n2.java.net----包含执行与网络相关的操作的类和接口。\n3.java.io----包含能提供多种输入/输出功能的类。\n4.java.util----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。\n5.java.text----包含了一些 java 格式化相关的类\n6.java.sql----包含了 java 进行 JDBC 数据库编程的相关类/接口\n7.java.awt----包含了构成抽象窗口工具集（abstractwindowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。B/S  C/S\n\n    import java.util.*;\n\nimport account2.Bank;\n\n/*\n * 二、import关键字的使用\n * import:导入\n * 1.在源文件中显式的使用import结构导入指定包下的类、接口\n * 2.声明在包的声明和类的声明之间\n * 3.如果需要导入多个结构，则并列写出即可\n * 4.可以使用\"xxx.*\"的方式,表示可以导入xxx包下的所有结构。\n * 5.如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。\n * 6.如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。\n * 7.如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。\n * 8.import static组合的使用：调用指定类或接口下的静态的属性或方法.\n * \n */\npublic class PackageImportTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tString info = Arrays.toString(new int[]&#123;1,2,3&#125;);\n\t\t\n\t\tBank bank = new Bank();\n\t\t\n\t\tArrayList list = new ArrayList();\n\t\tHashMap map = new HashMap();\n\t\t\n\t\tScanner s = null;\t\n\t\t\n\t\tSystem.out.println(\"hello\");\n\t\t\n\t\tUserTest us = new UserTest();\n\t\t\n\t&#125;\n&#125;\n\n\n7,MVC设计模式MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性。\n\n  \n4，面向对象21，继承性public class Person&#123;\n    String name;\n    private int age;\n    public Person()&#123;\n        \n    &#125;\n    public Person(String name,int age)&#123;\n        this.name&#x3D;name;\n        this.age&#x3D;age;\n    &#125;\n&#125;\n\n","slug":"java基础","date":"2022-11-07T13:52:40.247Z","categories_index":"后端","tags_index":"","author_index":"Aurora"}]